<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Keyword Hierarchy Dashboard</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ”‘</text></svg>">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Airy, modern theme with improved typography */
        :root {
            --bg-primary: #fafbfc;          /* Very light blue-grey background */
            --bg-secondary: #ffffff;        /* Pure white secondary */
            --bg-card: #ffffff;             /* White card background */
            --text-primary: #2d3748;        /* Dark blue-grey text */
            --text-secondary: #4a5568;      /* Medium blue-grey text */
            --text-muted: #718096;          /* Light blue-grey text */
            --border-color: #e2e8f0;        /* Very light grey border */
            --accent-primary: #3182ce;      /* Modern blue accent */
            --accent-secondary: #38a169;    /* Modern green accent */
            --accent-tertiary: #ed8936;     /* Modern orange accent */
            --accent-cool: #3182ce;         /* Cool blue accent (was missing) */
            --success-color: #38a169;       /* Modern green */
            --warning-color: #ed8936;       /* Modern orange */
            --danger-color: #e53e3e;        /* Modern red */
            --h1-color: #e53e3e;            /* Modern red for H1 */
            --h2-color: #3182ce;            /* Modern blue for H2 */
            --h3-color: #38a169;            /* Modern green for H3 */
            --shadow-soft: rgba(0, 0, 0, 0.05);
            --shadow-medium: rgba(0, 0, 0, 0.1);
            --shadow-large: rgba(0, 0, 0, 0.15);
            --font-primary: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            --font-secondary: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        body {
            background-color: var(--bg-primary);
            font-family: var(--font-primary);
            color: var(--text-primary);
            line-height: 1.7;
            font-weight: 400;
            letter-spacing: -0.01em;
        }

        .main-container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px 15px;
        }

        /* Typography improvements */
        h1, h2, h3, h4, h5, h6 {
            font-family: var(--font-secondary);
            font-weight: 600;
            letter-spacing: -0.02em;
            line-height: 1.3;
        }

        .display-4 {
            font-weight: 700;
            letter-spacing: -0.03em;
            color: var(--text-primary) !important;
        }

        /* Override for the main heading to ensure dark orange color */
        h1.display-4 {
            color: #e1640a !important;
        }

        .lead {
            font-size: 0.95rem;
            font-weight: 400;
            line-height: 1.5;
            color: var(--text-secondary) !important;
        }

        .upload-area {
            border: 2px dashed var(--border-color);
            border-radius: 12px;
            padding: 40px 30px;
            text-align: center;
            background: var(--bg-card);
            transition: all 0.3s ease;
            cursor: pointer;
            box-shadow: 0 1px 3px var(--shadow-soft);
            margin-bottom: 25px;
        }

        .upload-area:hover {
            border-color: var(--accent-primary);
            background-color: #f7fafc;
            box-shadow: 0 4px 20px var(--shadow-medium);
            transform: translateY(-2px);
        }

        .upload-area.dragover {
            border-color: var(--accent-primary);
            background-color: #ebf8ff;
            transform: scale(1.02);
        }

        .keyword-card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 12px 14px;
            margin-bottom: 8px;
            transition: all 0.3s ease;
            cursor: move;
            box-shadow: 0 1px 3px var(--shadow-soft);
            position: relative;
        }

        .keyword-card:hover {
            box-shadow: 0 8px 25px var(--shadow-medium);
            transform: translateY(-3px);
            border-color: var(--accent-primary);
        }

        .keyword-card.dragging {
            opacity: 0.7;
            transform: rotate(2deg);
        }

        /* Identifier section styling */
        .identifier-section {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            transition: all 0.3s ease;
            margin-bottom: 25px;
        }

        .identifier-section:hover {
            border-color: var(--accent-primary);
            box-shadow: 0 4px 16px var(--shadow-medium);
        }

        .identifier-section .card-header {
            background: #1e3a8a;
            border-bottom: 1px solid #1e40af;
            border-radius: 12px 12px 0 0;
            padding: 16px 20px 14px;
            color: white;
        }

        .identifier-section .card-header h5,
        .identifier-section .card-header small {
            color: white !important;
        }

        /* General card header styling - warm dark blue with white text */
        .card-header {
            background: #1e3a8a !important;
            border-bottom: 1px solid #1e40af !important;
            color: white !important;
        }

        .card-header h5,
        .card-header h6,
        .card-header small,
        .card-header .text-muted {
            color: white !important;
        }

        .identifier-section .card-body {
            padding: 20px;
        }

        /* H1 Keywords - Small and compact with very light red background */
        .tag-h1 {
            background: #fff5f5;
            border: 2px solid var(--text-primary);
            box-shadow: 0 2px 8px var(--shadow-soft);
            position: relative;
            padding: 12px 14px !important;
        }

        .tag-h1::before {
            content: "H1";
            position: absolute;
            top: -6px;
            left: 8px;
            background: var(--text-primary);
            color: var(--bg-card);
            padding: 1px 6px;
            border-radius: 4px;
            font-size: 0.6em;
            font-weight: 700;
            z-index: 1;
        }

        .tag-h1 .keyword-text {
            color: var(--text-primary) !important;
            font-weight: 600;
            font-size: 1.0em;
            letter-spacing: -0.01em;
        }

        /* H2 Keywords - Small and compact with very light blue background */
        .tag-h2 {
            background: #f0f8ff;
            border: 2px solid var(--text-secondary);
            box-shadow: 0 2px 6px var(--shadow-soft);
            padding: 12px 14px !important;
        }

        .tag-h2 .keyword-text {
            color: var(--text-primary) !important;
            font-weight: 600;
            font-size: 1.0em;
            letter-spacing: -0.01em;
        }

        /* H3 Keywords - Small and compact with green background */
        .tag-h3 {
            background: #ccd660;
            border: 2px solid var(--border-color);
            box-shadow: 0 1px 4px var(--shadow-soft);
            padding: 12px 14px !important;
        }

        .tag-h3 .keyword-text {
            color: var(--text-primary) !important;
            font-weight: 500;
            font-size: 0.95em;
        }

        /* Untagged keywords - Subtle styling */
        .tag-untagged {
            background: var(--bg-card);
            border: 2px dashed var(--text-muted);
            box-shadow: 0 1px 3px var(--shadow-soft);
            position: relative;
            padding: 12px 14px !important;
        }

        .tag-untagged .keyword-text {
            color: #000000 !important;
            font-weight: 500;
            font-size: 0.95em;
        }

        .volume-badge {
            font-size: 0.75em;
            padding: 6px 10px;
            background: rgba(255, 255, 255, 0.95) !important;
            color: var(--text-primary) !important;
            border: 1px solid var(--border-color);
            font-weight: 600;
            border-radius: 8px;
            letter-spacing: 0.01em;
        }

        .controls-panel {
            background: var(--bg-card);
            border-radius: 20px;
            padding: 40px;
            margin-bottom: 40px;
            box-shadow: 0 2px 8px var(--shadow-soft);
            border: 1px solid var(--border-color);
        }

        .keywords-container {
            background: var(--bg-card);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 2px 8px var(--shadow-soft);
            border: 1px solid var(--border-color);
        }

        .btn-tag {
            border: none;
            border-radius: 12px;
            padding: 10px 20px;
            margin: 4px;
            font-size: 0.9em;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px var(--shadow-soft);
            letter-spacing: 0.01em;
        }

        .btn-tag:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px var(--shadow-medium);
        }

        .btn-outline-danger {
            color: var(--text-primary);
            border-color: var(--text-primary);
            background: var(--bg-card);
            border-width: 2px;
            font-weight: 600;
        }

        .btn-outline-danger:hover {
            color: var(--bg-card);
            background: var(--text-primary);
            border-color: var(--text-primary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px var(--shadow-medium);
        }

        .btn-outline-success {
            color: var(--text-secondary);
            border-color: var(--text-secondary);
            background: var(--bg-card);
            border-width: 2px;
            font-weight: 600;
        }

        .btn-outline-success:hover {
            color: var(--bg-card);
            background: var(--text-secondary);
            border-color: var(--text-secondary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px var(--shadow-medium);
        }

        .btn-outline-info {
            color: var(--text-muted);
            border-color: var(--text-muted);
            background: var(--bg-card);
            border-width: 2px;
            font-weight: 600;
        }

        .btn-outline-info:hover {
            color: var(--bg-card);
            background: var(--text-muted);
            border-color: var(--text-muted);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px var(--shadow-medium);
        }

        .btn-remove {
            background: var(--danger-color);
            color: white;
            border: none;
            border-radius: 8px;
            width: 36px;
            height: 36px;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 6px rgba(220, 53, 69, 0.3);
        }

        .btn-remove:hover {
            background: #c82333;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(220, 53, 69, 0.5);
        }

        .drag-handle {
            cursor: move;
            color: var(--text-muted);
            margin-right: 12px;
            font-size: 16px;
        }

        .keyword-text {
            font-weight: 600;
            transition: all 0.3s ease;
            line-height: 1.4;
            font-size: 1.1em;
            letter-spacing: -0.01em;
        }

        .keyword-text:hover {
            text-decoration: none;
            color: var(--accent-primary);
        }

        .keyword-text.selected {
            color: var(--text-primary) !important;
            padding: 6px 10px !important;
            border-radius: 8px !important;
            box-shadow: 0 2px 8px var(--shadow-soft) !important;
            font-weight: 700 !important;
            position: relative !important;
        }

        /* Maintain hierarchy colors when selected - just add subtle highlight */
        .tag-h1 .keyword-text.selected {
            background: rgba(229, 62, 62, 0.15) !important; /* Light red background for H1 */
            border: 2px solid var(--h1-color) !important;
            color: var(--text-primary) !important;
            box-shadow: 0 2px 8px rgba(229, 62, 62, 0.2) !important;
            font-weight: 600 !important; /* Maintain H1 font weight */
            font-size: 1.0em !important; /* Maintain H1 font size */
            letter-spacing: -0.01em !important; /* Maintain H1 letter spacing */
        }

        .tag-h2 .keyword-text.selected {
            background: rgba(49, 130, 206, 0.15) !important; /* Light blue background for H2 */
            border: 2px solid var(--h2-color) !important;
            color: var(--text-primary) !important;
            box-shadow: 0 2px 8px rgba(49, 130, 206, 0.2) !important;
            font-weight: 600 !important; /* Maintain H2 font weight */
            font-size: 1.0em !important; /* Maintain H2 font size */
            letter-spacing: -0.01em !important; /* Maintain H2 letter spacing */
        }

        .tag-h3 .keyword-text.selected {
            background: rgba(56, 161, 105, 0.15) !important; /* Light green background for H3 */
            border: 2px solid var(--h3-color) !important;
            color: var(--text-primary) !important;
            box-shadow: 0 2px 8px rgba(56, 161, 105, 0.2) !important;
            font-weight: 500 !important; /* Maintain H3 font weight */
            font-size: 0.95em !important; /* Maintain H3 font size */
        }

        /* Ultra-high specificity override for debugging - REMOVED */
        /* This was causing all selected keywords to appear red regardless of hierarchy */

        /* Hover effects for selected keywords - maintain hierarchy colors */
        .tag-h1 .keyword-text.selected:hover {
            background: rgba(229, 62, 62, 0.25) !important;
            transform: scale(1.02) !important;
            box-shadow: 0 4px 12px rgba(229, 62, 62, 0.3) !important;
        }

        .tag-h2 .keyword-text.selected:hover {
            background: rgba(49, 130, 206, 0.25) !important;
            transform: scale(1.02) !important;
            box-shadow: 0 4px 12px rgba(49, 130, 206, 0.3) !important;
        }

        .tag-h3 .keyword-text.selected:hover {
            background: rgba(56, 161, 105, 0.25) !important;
            transform: scale(1.02) !important;
            box-shadow: 0 4px 12px rgba(56, 161, 105, 0.3) !important;
        }

        /* Remove the "SELECTED" badges - just use subtle highlighting */
        .keyword-text.selected::before {
            content: none;
        }

        /* No specific badges for selected keywords */
        .tag-h1 .keyword-text.selected::before {
            content: none;
        }

        .tag-h2 .keyword-text.selected::before {
            content: none;
        }

        .tag-h3 .keyword-text.selected::before {
            content: none;
        }

        /* General hover for non-H1/H2/H3 selected keywords */
        .keyword-text.selected:hover {
            background: rgba(59, 130, 246, 0.15) !important;
            color: var(--text-primary) !important;
            text-decoration: none !important;
            transform: scale(1.02) !important;
        }

        /* Ensure hierarchy colors are maintained even when multiple keywords are selected */
        .tag-h1 .keyword-text.selected,
        .tag-h1 .keyword-text.selected:hover {
            color: var(--text-primary) !important;
            font-weight: 800 !important;
            font-size: 1.8em !important;
            letter-spacing: -0.02em !important;
        }

        .tag-h2 .keyword-text.selected,
        .tag-h2 .keyword-text.selected:hover {
            color: var(--text-primary) !important;
            font-weight: 700 !important;
            font-size: 1.4em !important;
            letter-spacing: -0.01em !important;
        }

        .tag-h3 .keyword-text.selected,
        .tag-h3 .keyword-text.selected:hover {
            color: var(--text-primary) !important;
            font-weight: 600 !important;
            font-size: 1.1em !important;
        }

        .keyword-text.editing {
            background: var(--bg-secondary);
            border: 2px solid var(--accent-cool);
            border-radius: 8px;
            padding: 6px 12px;
            outline: none;
            box-shadow: 0 0 0 3px rgba(13, 110, 253, 0.2);
            color: var(--text-primary);
        }

        .edit-input {
            background: var(--bg-secondary);
            border: 2px solid var(--accent-cool);
            border-radius: 8px;
            padding: 6px 12px;
            outline: none;
            font-size: inherit;
            font-weight: inherit;
            width: 100%;
            box-shadow: 0 0 0 3px rgba(13, 110, 253, 0.2);
            color: var(--text-primary);
        }

        .edit-buttons {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .edit-btn {
            padding: 4px 12px;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .save-btn {
            background: var(--success-color);
            color: white;
        }

        .save-btn:hover {
            background: #157347;
        }

        .cancel-btn {
            background: var(--danger-color);
            color: white;
        }

        .cancel-btn:hover {
            background: #c82333;
        }

        .intent-badge {
            font-size: 0.8em;
            padding: 6px 10px;
            border-radius: 10px;
            background: var(--bg-primary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
            font-weight: 500;
            letter-spacing: 0.01em;
        }

        .keyword-checkbox {
            border: 2px solid var(--text-secondary) !important;
            border-radius: 4px !important;
            width: 20px !important;
            height: 20px !important;
        }

        .keyword-checkbox:checked {
            background-color: var(--accent-cool) !important;
            border-color: var(--accent-cool) !important;
        }

        .form-check {
            margin-right: 18px !important;
        }

        .h3-container {
            background: var(--bg-primary);
            border-radius: 12px;
            margin-top: 12px;
            margin-bottom: 12px;
            border: 1px solid var(--border-color);
            padding: 16px;
        }

        .copy-icon {
            transition: all 0.2s ease;
            opacity: 0.7;
        }

        .copy-icon:hover {
            opacity: 1;
            color: var(--accent-primary) !important;
            transform: scale(1.1);
        }

        .copy-icon.copied {
            color: var(--accent-secondary) !important;
            animation: copySuccess 0.5s ease;
        }

        @keyframes copySuccess {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        .h3-container .keyword-card {
            margin-bottom: 10px;
            border-left: 4px solid var(--accent-cool);
        }
        
        /* Ensure H3 keywords maintain their green background even when nested */
        .h3-container .keyword-card.tag-h3 {
            background: #ccd660;
        }

        .h3-container .keyword-card:last-child {
            margin-bottom: 0;
        }

        .search-results-list {
            max-height: 350px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 12px;
            background: var(--bg-primary);
        }

        .search-result-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 18px;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-card);
            transition: all 0.3s ease;
        }

        .search-result-item:hover {
            background: #f8f9ff;
        }

        .search-result-item:last-child {
            border-bottom: none;
        }

        .search-result-info {
            flex-grow: 1;
        }

        .search-result-keyword {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
            font-size: 1.1em;
        }

        .search-result-details {
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        .search-result-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .search-result-tag {
            font-size: 0.8em;
            padding: 4px 8px;
            border-radius: 12px;
            font-weight: 600;
        }

        .search-result-tag.h1 {
            background: var(--text-primary);
            color: var(--bg-card);
            border: 1px solid var(--text-primary);
            font-weight: 700;
        }

        .search-result-tag.h2 {
            background: var(--text-secondary);
            color: var(--bg-card);
            border: 1px solid var(--text-secondary);
            font-weight: 600;
        }

        .search-result-tag.h3 {
            background: var(--text-muted);
            color: var(--bg-card);
            border: 1px solid var(--text-muted);
            font-weight: 500;
        }

        .search-result-tag.untagged {
            background: var(--text-muted);
            color: var(--bg-card);
            border: 1px dashed var(--text-muted);
            font-weight: 400;
        }

        .keyword-card.tag-h2.drag-over {
            border: 2px dashed var(--h2-color) !important;
            background-color: rgba(13, 110, 253, 0.1) !important;
            transform: scale(1.02) !important;
            transition: all 0.3s ease;
            box-shadow: 0 6px 16px var(--shadow-medium) !important;
        }
        
        /* H2 section reordering styles */
        .keyword-card.tag-h2 {
            cursor: grab;
            transition: all 0.3s ease;
        }
        
        .keyword-card.tag-h2:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px var(--shadow-medium);
        }
        
        .keyword-card.tag-h2:active {
            cursor: grabbing;
            transform: scale(0.98);
        }
        
        .keyword-card.tag-h2.dragging {
            opacity: 0.8;
            transform: rotate(2deg) scale(1.05);
            box-shadow: 0 8px 16px var(--shadow-medium);
            z-index: 1000;
        }
        
        /* Enhanced drag handle for H2 sections */
        .keyword-card.tag-h2 .drag-handle {
            color: var(--h2-color);
            font-size: 18px;
            margin-right: 15px;
            cursor: grab;
            transition: all 0.3s ease;
        }
        
        .keyword-card.tag-h2 .drag-handle:hover {
            color: var(--accent-primary);
            transform: scale(1.1);
        }
        
        .keyword-card.tag-h2:active .drag-handle {
            cursor: grabbing;
        }

        /* Reorder buttons styling */
        .reorder-buttons {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .reorder-btn {
            padding: 4px 6px;
            font-size: 10px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: var(--bg-card);
            color: var(--text-muted);
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .reorder-btn:hover {
            background: var(--accent-primary);
            color: white;
            border-color: var(--accent-primary);
            transform: scale(1.1);
        }

        .reorder-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .reorder-btn:disabled:hover {
            background: var(--bg-card);
            color: var(--text-muted);
            border-color: var(--border-color);
            transform: none;
        }

        .keyword-card.tag-h3 {
            cursor: grab;
            transition: all 0.3s ease;
        }

        .keyword-card.tag-h3:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px var(--shadow-medium);
        }

        .keyword-card.tag-h3:active {
            cursor: grabbing;
            transform: scale(0.98);
        }

        .keyword-card.tag-h3.dragging {
            opacity: 0.8;
            transform: rotate(2deg) scale(1.05);
            box-shadow: 0 8px 16px var(--shadow-medium);
        }

        .keyword-card.tag-h2 {
            position: relative;
        }

        .keyword-card.tag-h2::after {
            content: "Drop H3 here";
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--h2-color);
            color: #ffffff;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 0.8em;
            font-weight: 700;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            box-shadow: 0 4px 12px var(--shadow-medium);
            border: 2px solid #000000;
        }

        .keyword-card.tag-h2.drag-over::after {
            opacity: 1;
        }

        /* Additional neutral theme improvements */
        .display-4 {
            color: var(--text-primary) !important;
            font-weight: 700;
        }

        .text-primary {
            color: var(--accent-cool) !important;
        }

        .text-muted {
            color: var(--text-muted) !important;
        }

        .text-dark {
            color: var(--text-primary) !important;
        }

        .form-control {
            border-color: var(--border-color);
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            border-radius: 12px;
            padding: 12px 16px;
            font-size: 1rem;
            transition: all 0.3s ease;
            border-width: 1px;
        }

        .form-control:focus {
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(49, 130, 206, 0.1);
            background-color: var(--bg-secondary);
        }

        .btn-primary {
            background-color: var(--accent-primary);
            border-color: var(--accent-primary);
            color: #ffffff;
            font-weight: 600;
            border-radius: 12px;
            padding: 12px 24px;
            transition: all 0.3s ease;
            letter-spacing: 0.01em;
        }

        .btn-primary:hover {
            background-color: #2c5282;
            border-color: #2c5282;
            color: #ffffff;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(49, 130, 206, 0.3);
        }

        .btn-success {
            background-color: var(--success-color);
            border-color: var(--success-color);
            color: #ffffff;
            font-weight: 600;
        }

        .btn-success:hover {
            background-color: #157347;
            border-color: #157347;
            color: #ffffff;
        }

        .btn-warning {
            background-color: var(--warning-color);
            border-color: var(--warning-color);
            color: #ffffff;
            font-weight: 600;
        }

        .btn-warning:hover {
            background-color: #e55a2b;
            border-color: #e55a2b;
            color: #ffffff;
        }

        .btn-danger {
            background-color: var(--danger-color);
            border-color: var(--danger-color);
            color: #ffffff;
            font-weight: 600;
        }

        .btn-danger:hover {
            background-color: #c82333;
            border-color: #c82333;
            color: #ffffff;
        }

        .btn-secondary {
            background-color: var(--text-secondary);
            border-color: var(--text-secondary);
            color: #ffffff;
            font-weight: 600;
        }

        .btn-secondary:hover {
            background-color: #5a6268;
            border-color: #5a6268;
            color: #ffffff;
        }

        .badge {
            font-size: 0.85em;
            padding: 6px 10px;
        }

        .badge.bg-primary {
            background-color: var(--accent-cool) !important;
            color: #ffffff !important;
        }

        .badge.bg-secondary {
            background-color: var(--text-secondary) !important;
            color: #ffffff !important;
        }

        /* Scrollbar styling for neutral theme */
        ::-webkit-scrollbar {
            width: 12px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-primary);
            border-radius: 6px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--text-muted);
            border-radius: 6px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }

        /* Focus indicators for accessibility */
        .btn:focus,
        .form-control:focus,
        .keyword-text:focus {
            outline: 2px solid var(--accent-cool);
            outline-offset: 2px;
        }

        /* Reduce motion for users who prefer it */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Image Upload Section Styles */
        .image-upload-section {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            transition: all 0.3s ease;
        }

        .image-upload-section:hover {
            border-color: var(--accent-primary);
            box-shadow: 0 4px 16px var(--shadow-medium);
        }

        .upload-section {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .pexels-image-card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .pexels-image-card:hover {
            border-color: var(--accent-primary);
            box-shadow: 0 4px 12px var(--shadow-medium);
            transform: translateY(-2px);
        }

        .pexels-image-card.selected {
            border-color: var(--accent-primary);
            background: #ebf8ff;
            box-shadow: 0 4px 12px var(--shadow-medium);
        }

        .image-wrapper {
            width: 100%;
            aspect-ratio: 1 / 1;
            overflow: hidden;
            border-radius: 6px;
            margin-bottom: 10px;
        }
        
        .pexels-image-card img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 6px;
        }

        .selected-image-item {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }

        .selected-image-item:hover {
            border-color: var(--accent-primary);
            box-shadow: 0 4px 12px var(--shadow-medium);
        }

        .selected-image-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 6px;
        }

        .image-filename-input {
            font-size: 0.9em;
            padding: 8px 12px;
        }

        .upload-progress {
            background: #e2e8f0;
            border-radius: 4px;
            height: 8px;
            margin-top: 8px;
        }

        .upload-progress-bar {
            background: var(--accent-primary);
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .cloudinary-url {
            background: #f7fafc;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 8px 12px;
            font-family: monospace;
            font-size: 0.85em;
            word-break: break-all;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="text-center mb-4">
            <h1 class="display-4" style="color: #e1640a;">
                <i class="fas fa-key"></i> Keyword Hierarchy Dashboard
            </h1>
        </div>

        <!-- Upload Section -->
        <div class="upload-area" id="uploadArea" onclick="document.getElementById('fileInput').click()">
            <i class="fas fa-cloud-upload-alt fa-3x text-muted mb-3"></i>
            <h4>Upload SEMrush CSV File</h4>
            <p class="text-muted">Click to browse or drag and drop your CSV file here</p>
            <input type="file" id="fileInput" accept=".csv" style="display: none;">
        </div>

        <!-- Identifier Section -->
        <div class="card mt-4 identifier-section">
            <div class="card-header">
                <h5 class="mb-0"><i class="fas fa-tags"></i> Project Identifier</h5>
            </div>
            <div class="card-body">
                <div class="row">
                                   <div class="col-md-6">
                   <div class="form-group">
                       <label for="projectHandle" class="form-label">Handle</label>
                       <input type="text" class="form-control" id="projectHandle" required>
                   </div>
               </div>
               <div class="col-md-6">
                   <div class="form-group">
                       <label for="projectTags" class="form-label">Tags</label>
                       <input type="text" class="form-control" id="projectTags" required>
                   </div>
               </div>
                </div>
            </div>
        </div>

        <!-- Hero Section -->
        <div class="card mt-4 hero-section">
            <div class="card-header">
                <h5 class="mb-0"><i class="fas fa-star"></i> Hero Section</h5>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-4">
                        <div class="form-group">
                            <label for="heroTagline" class="form-label">Tagline</label>
                            <input type="text" class="form-control" id="heroTagline" required>
                        </div>
                    </div>
                    <div class="col-md-4">
                        <div class="form-group">
                            <label for="heroCTA" class="form-label">CTA Text</label>
                            <select class="form-control" id="heroCTA" required>
                                <option value="">Select CTA text...</option>
                                <option value="Book Now!">Book Now!</option>
                                <option value="Book with Bea">Book with Bea</option>
                                <option value="Schedule with Bea">Schedule with Bea</option>
                                <option value="Meet Bea">Meet Bea</option>
                                <option value="Reserve with Bea">Reserve with Bea</option>
                                <option value="Plan with Bea">Plan with Bea</option>
                            </select>
                        </div>
                    </div>
                    <div class="col-md-4">
                        <div class="form-group">
                                                           <label for="heroCTALink" class="form-label">CTA Link</label>
                               <select class="form-control" id="heroCTALink" required>
                                 <option value="https://bea-nails.bookbuy.ca/">https://bea-nails.bookbuy.ca/</option>
                               </select>
                        </div>
                    </div>
                </div>
                <div class="row mt-3">
                    <div class="col-md-6">
                        <div class="form-group">
                            <label for="heroImageUrl" class="form-label">Hero Image URL</label>
                            <select class="form-control" id="heroImageUrl" required>
                                <option value="">Select hero image...</option>
                                <option value="https://res.cloudinary.com/dvpoab5n3/image/upload/v1755166888/bea-professional-nail-technician-toronto.png">https://res.cloudinary.com/dvpoab5n3/image/upload/v1755166888/bea-professional-nail-technician-toronto.png</option>
                            </select>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="form-group">
                            <label for="heroAltText" class="form-label">Alt Text Image</label>
                            <select class="form-control" id="heroAltText" required>
                                <option value="">Select alt text...</option>
                                <option value="Professional nail technician Bea in Toronto portrait photography">Professional nail technician Bea in Toronto portrait photography</option>
                                <option value="Bea expert nail artist in downtown Toronto professional headshot">Bea expert nail artist in downtown Toronto professional headshot</option>
                                <option value="Toronto nail professional Bea posing for beauty industry profile photo">Toronto nail professional Bea posing for beauty industry profile photo</option>
                                <option value="Bea certified nail technician in downtown Toronto professional portrait">Bea certified nail technician in downtown Toronto professional portrait</option>
                                <option value="Professional image of Bea nail technician and artist in Toronto">Professional image of Bea nail technician and artist in Toronto</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Image Upload Section -->
        <div class="card mt-4 image-upload-section">
            <div class="card-header">
                <h5 class="mb-0"><i class="fas fa-images"></i> Image Upload</h5>
            </div>
            <div class="card-body">
                <!-- Upload Options -->
                <div class="row mb-3">
                    <div class="col-md-6">
                        <button class="btn btn-outline-primary w-100" onclick="showUploadOption('local')">
                            <i class="fas fa-upload"></i> Upload from Computer
                        </button>
                    </div>
                    <div class="col-md-6">
                        <button class="btn btn-outline-success w-100" onclick="showUploadOption('pexels')">
                            <i class="fas fa-search"></i> Search Pexels
                        </button>
                    </div>
                </div>

                <!-- Local Upload Section -->
                <div id="localUploadSection" class="upload-section" style="display: none;">
                    <div class="mb-3">
                        <label for="imageFileInput" class="form-label">Choose Image File</label>
                        <input type="file" class="form-control" id="imageFileInput" accept="image/*" multiple>
                    </div>
                </div>

                <!-- Pexels Search Section -->
                <div id="pexelsSearchSection" class="upload-section" style="display: none;">
                    <div class="mb-3">
                        <div class="input-group">
                            <input type="text" class="form-control" id="pexelsSearchInput">
                            <button class="btn btn-primary" onclick="searchPexels()">
                                <i class="fas fa-search"></i> Search
                            </button>
                        </div>
                    </div>
                    <div id="pexelsResults" class="row"></div>
                    <div id="loadMoreSection" class="text-center mt-3" style="display: none;">
                        <button class="btn btn-outline-primary" onclick="loadMorePexels()">
                            <i class="fas fa-plus"></i> Load More Images
                        </button>
                    </div>
                </div>

                <!-- Selected Images Section -->
                <div id="selectedImagesSection" style="display: none;">
                    <h6 class="mb-3">Selected Images</h6>
                    
                    <!-- Bulk Actions -->
                    <div class="row mb-3">
                        <div class="col-md-6">
                            <div class="input-group">
                                <input type="text" class="form-control" id="bulkFileName">
                                <button class="btn btn-outline-secondary" onclick="applyBulkFileName()">
                                    <i class="fas fa-copy"></i> Apply to All
                                </button>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <button class="btn btn-success" onclick="uploadToCloudinary()">
                                <i class="fas fa-cloud-upload-alt"></i> Upload to Cloudinary
                            </button>
                        </div>
                    </div>

                    <!-- Images List -->
                    <div id="selectedImagesList" class="row"></div>
                </div>
            </div>
        </div>

        <!-- Controls Panel -->
        <div class="controls-panel" id="controlsPanel" style="display: none;">
            <div class="row align-items-center justify-content-between">
                <div class="col-md-2">
                    <div class="input-group">
                        <input type="number" class="form-control" id="volumeFilter" value="400" min="0">
                        <button class="btn btn-dark" onclick="filterKeywords()">
                            <i class="fas fa-filter"></i> Filter
                        </button>
                    </div>
                </div>
                <div class="col-md-3">
                    <div class="d-flex gap-3">
                        <button class="btn btn-dark" onclick="downloadStructuredJSON()">
                            <i class="fas fa-download"></i> Download JSON
                        </button>
                        <button class="btn btn-primary" onclick="handleGenerateOrDownload()" id="generateBtn">
                            <i class="fas fa-magic"></i> Generate Content
                        </button>
                    </div>
                </div>
                <div class="col-md-4 ms-4">
                    <div class="d-flex gap-3 align-items-center">
                        <div class="form-check me-4">
                            <input class="form-check-input" type="checkbox" id="selectAllCheckbox" onchange="toggleSelectAll()">
                            <label class="form-check-label" for="selectAllCheckbox">
                                <strong>Select All</strong>
                            </label>
                        </div>
                        <button class="btn btn-dark" onclick="addNewH2()">
                            <i class="fas fa-plus"></i> Add H2
                        </button>
                        <button class="btn btn-danger" onclick="removeSelectedH2s()" id="removeH2Btn" style="display: none;">
                            <i class="fas fa-trash"></i> Remove Selected
                        </button>
                    </div>
                </div>
                <div class="col-md-2">
                    <div class="d-flex justify-content-end align-items-center">
                        <span class="badge bg-dark" id="keywordCount">0 keywords</span>
                    </div>
                </div>
            </div>
        </div>



        <!-- Keywords Container -->
        <div class="keywords-container" id="keywordsContainer" style="display: none;">
            <h4 class="mb-3">
                <i class="fas fa-list"></i> Keywords
            </h4>
            
            <!-- Search Section -->
            <div class="search-section mb-4">
                <div class="input-group">
                    <span class="input-group-text">
                        <i class="fas fa-search"></i>
                    </span>
                    <input type="text" class="form-control" id="keywordSearch" oninput="searchKeywords()">
                    <button class="btn btn-outline-secondary" type="button" onclick="clearSearch()">
                        <i class="fas fa-times"></i> Clear
                    </button>
                </div>
                <div id="searchResults" class="mt-3" style="display: none;">
                    <h6 class="text-muted mb-2">
                        <i class="fas fa-search"></i> Search Results
                        <span id="searchCount" class="badge bg-primary ms-2">0</span>
                    </h6>
                    <div id="searchResultsList" class="search-results-list"></div>
                </div>
            </div>
            
            <div id="keywordsList"></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        let currentData = [];
        let filteredData = [];

        // File upload handling
        const fileInput = document.getElementById('fileInput');
        
        fileInput.addEventListener('change', (event) => {
            console.log('File input change event triggered'); // Debug log
            handleFileUpload(event);
        });
        
        // Drag and drop
        const uploadArea = document.getElementById('uploadArea');
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        function handleFileUpload(event) {
            console.log('handleFileUpload called'); // Debug log
            console.log('Event target files:', event.target.files); // Debug log
            const file = event.target.files[0];
            if (file) {
                console.log('File selected:', file.name, file.type); // Debug log
                handleFile(file);
            } else {
                console.log('No file selected'); // Debug log
            }
        }

        function handleFile(file) {
            console.log('handleFile called with:', file.name); // Debug log
            const formData = new FormData();
            formData.append('file', file);

            console.log('Sending request to /upload'); // Debug log
            fetch('/upload', {
                method: 'POST',
                body: formData
            })
            .then(response => {
                console.log('Response status:', response.status); // Debug log
                return response.json();
            })
            .then(data => {
                console.log('Response data:', data); // Debug log
                if (data.success) {
                    currentData = data.data;
                    filteredData = currentData.filter(kw => kw.volume >= 400);
                    showControls();
                    renderKeywords();
                    showNotification(data.message, 'success');
                } else {
                    showNotification(data.error, 'error');
                }
            })
            .catch(error => {
                console.error('Error:', error); // Debug log
                showNotification('Error uploading file: ' + error.message, 'error');
            });
        }

        function filterKeywords() {
            const minVolume = parseInt(document.getElementById('volumeFilter').value);
            
            fetch('/filter', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ min_volume: minVolume })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    filteredData = data.data;
                    renderKeywords();
                    showNotification(`Filtered to ${data.count} keywords. Working with filtered data only.`, 'success');
                } else {
                    showNotification(data.error, 'error');
                }
            })
            .catch(error => {
                showNotification('Error filtering keywords: ' + error.message, 'error');
            });
        }

        function assignTag(keywordId, tag) {
            fetch('/update_tags', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    updates: [{ id: keywordId, tag: tag }]
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Update local data
                    const keyword = filteredData.find(kw => kw.id === keywordId);
                    if (keyword) {
                        keyword.tag = tag;
                        
                        // If assigning H3 tag, automatically assign parent H2
                        if (tag === 'H3') {
                            assignParentH2(keywordId);
                        }
                    }
                    renderKeywords();
                    
                    // Preserve checkbox selections after rendering
                    setTimeout(() => {
                        // Restore checkbox selections after re-rendering
                        document.querySelectorAll('.keyword-checkbox').forEach(checkbox => {
                            if (checkbox.checked) {
                                const keywordCard = checkbox.closest('.keyword-card');
                                const keywordText = keywordCard.querySelector('.keyword-text');
                                if (keywordText) {
                                    keywordText.classList.add('selected');
                                }
                            }
                        });
                    }, 100);
                    
                    // Reset generate button since data has changed
                    resetGenerateButton();
                    
                    showNotification('Tag updated successfully', 'success');
                } else {
                    showNotification(data.error, 'error');
                }
            })
            .catch(error => {
                showNotification('Error updating tag: ' + error.message, 'error');
            });
        }
        
        function assignParentH2(h3KeywordId) {
            // Find the H2 keyword that comes before this H3 keyword
            const h3Keyword = filteredData.find(kw => kw.id === h3KeywordId);
            if (!h3Keyword) return;
            
            const h3Order = h3Keyword.order;
            const h2Keywords = filteredData.filter(kw => kw.tag === 'H2').sort((a, b) => b.order - a.order); // Sort descending
            
            // Find the closest H2 that comes before this H3
            for (const h2Kw of h2Keywords) {
                if (h2Kw.order < h3Order) {
                    // Assign this H2 as parent
                    h3Keyword.parent_id = h2Kw.id;
                    break;
                }
            }
        }

        function removeKeyword(keywordId) {
            // Remove without confirmation
            fetch('/remove_keyword', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ id: keywordId })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Remove from filtered data (this is what we're working with)
                    filteredData = filteredData.filter(kw => kw.id !== keywordId);
                    
                    // Update order
                    for (let i = 0; i < filteredData.length; i++) {
                        filteredData[i].order = i;
                    }
                    
                    // Update backend with the new data and wait for completion
                    updateBackendData().then(() => {
                        renderKeywords();
                        // Reset generate button since data has changed
                        resetGenerateButton();
                        showNotification('Keyword removed successfully', 'success');
                    }).catch(error => {
                        console.error('Error updating backend data:', error);
                        showNotification('Error updating data. Please try again.', 'error');
                    });
                } else {
                    showNotification(data.error, 'error');
                }
            })
            .catch(error => {
                showNotification('Error removing keyword: ' + error.message, 'error');
            });
        }


        function downloadStructuredJSON() {
            console.log('Downloading data - filteredData length:', filteredData.length);
            console.log('Downloading data - filteredData:', filteredData);
            
            // Get identifier data from form inputs
            const handle = document.getElementById('projectHandle').value.trim();
            const tags = document.getElementById('projectTags').value.trim();
            
            // Create the complete data structure with identifier
            const completeData = {
                identifier: {
                    handle: handle || 'default-handle',
                    tags: tags || 'default-tags'
                },
                data: filteredData
            };
            
            // Use completeData for download (includes identifier + filtered keywords)
            const dataToDownload = completeData;
            
            // First, ensure backend is synced with the data we want to download
            updateBackendData().then(() => {
                // Then download with a small delay to ensure backend has processed the update
                setTimeout(() => {
                    fetch('/download', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ data: dataToDownload })
                    })
                    .then(response => {
                        if (response.ok) {
                            return response.blob();
                        }
                        throw new Error('Download failed');
                    })
                    .then(blob => {
                        const url = window.URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'keyword_hierarchy.json';
                        document.body.appendChild(a);
                        a.click();
                        window.URL.revokeObjectURL(url);
                        document.body.removeChild(a);
                        showNotification('Structured JSON file downloaded successfully', 'success');
                    })
                    .catch(error => {
                        showNotification('Error downloading file: ' + error.message, 'error');
                    });
                }, 200); // 200ms delay after backend sync
            }).catch(error => {
                console.error('Error syncing with backend before download:', error);
                showNotification('Error syncing data before download. Please try again.', 'error');
            });
        }



        function renderKeywords() {
            const container = document.getElementById('keywordsList');
            const keywordCount = document.getElementById('keywordCount');
            
            keywordCount.textContent = `${filteredData.length} keywords`;
            
            container.innerHTML = '';
            
            // Group keywords by tag
            const h1Keywords = filteredData.filter(kw => kw.tag === 'H1');
            const h2Keywords = filteredData.filter(kw => kw.tag === 'H2');
            const h3Keywords = filteredData.filter(kw => kw.tag === 'H3');
            const untaggedKeywords = filteredData.filter(kw => !kw.tag);
            
            // Render H1 keywords
            if (h1Keywords.length > 0) {
                const h1Section = document.createElement('div');
                h1Section.className = 'mb-4';
                h1Section.innerHTML = '<h5 class="text-dark mb-3"><i class="fas fa-heading"></i> H1 Keywords</h5>';
                h1Keywords.forEach(keyword => {
                    h1Section.appendChild(createKeywordCard(keyword));
                });
                container.appendChild(h1Section);
            }
            
            // Render H2 keywords with their related H3 keywords
            if (h2Keywords.length > 0) {
                const h2Section = document.createElement('div');
                h2Section.className = 'mb-4';
                h2Section.innerHTML = '<h5 class="text-dark mb-3"><i class="fas fa-heading"></i> H2 Keywords</h5>';
                
                // Sort keywords by order
                h2Keywords.sort((a, b) => a.order - b.order);
                h3Keywords.sort((a, b) => a.order - b.order);
                
                h2Keywords.forEach(h2Keyword => {
                    // Create H2 card
                    const h2Card = createKeywordCard(h2Keyword, true);
                    
                    // Find H3 keywords that belong to this H2 using parent_id
                    const relatedH3Keywords = h3Keywords.filter(h3Kw => 
                        h3Kw.parent_id === h2Keyword.id
                    );
                    
                    // If there are related H3 keywords, create a container for them
                    if (relatedH3Keywords.length > 0) {
                        const h3Container = document.createElement('div');
                        h3Container.className = 'h3-container ms-4 mt-2';
                        h3Container.style.borderLeft = '3px solid #45b7d1';
                        h3Container.style.paddingLeft = '15px';
                        
                        // Add a small header to show this is H3 keywords
                        const h3Header = document.createElement('div');
                        h3Header.className = 'text-dark mb-2';
                        h3Header.style.fontSize = '0.9em';
                        h3Header.style.fontWeight = '500';
                        h3Header.innerHTML = `<i class="fas fa-level-down-alt"></i> Related H3 Keywords (${relatedH3Keywords.length})`;
                        h3Container.appendChild(h3Header);
                        
                        relatedH3Keywords.forEach(h3Keyword => {
                            const h3Card = createKeywordCard(h3Keyword, false);
                            h3Container.appendChild(h3Card);
                        });
                        
                        // Append H3 container to H2 card
                        h2Card.appendChild(h3Container);
                    }
                    
                    h2Section.appendChild(h2Card);
                });
                
                container.appendChild(h2Section);
            }
            
            // Render remaining H3 keywords (those that don't belong to any H2)
            const remainingH3Keywords = h3Keywords.filter(h3Kw => !h3Kw.parent_id);
            
            if (remainingH3Keywords.length > 0) {
                const h3Section = document.createElement('div');
                h3Section.className = 'mb-4';
                h3Section.innerHTML = '<h5 class="text-dark mb-3"><i class="fas fa-heading"></i> H3 Keywords (Unassigned)</h5>';
                remainingH3Keywords.forEach(keyword => {
                    h3Section.appendChild(createKeywordCard(keyword));
                });
                container.appendChild(h3Section);
            }
            
            // Render untagged keywords
            if (untaggedKeywords.length > 0) {
                const untaggedSection = document.createElement('div');
                untaggedSection.className = 'mb-4';
                untaggedSection.innerHTML = '<h5 class="text-dark mb-3"><i class="fas fa-tags"></i> Untagged Keywords</h5>';
                untaggedKeywords.forEach(keyword => {
                    untaggedSection.appendChild(createKeywordCard(keyword));
                });
                container.appendChild(untaggedSection);
            }
            
            setupDragAndDrop();
            updateRemoveButton();
        }
        
        function createKeywordCard(keyword, isH2 = false) {
            const card = document.createElement('div');
            card.className = `keyword-card ${keyword.tag ? 'tag-' + keyword.tag.toLowerCase() : 'tag-untagged'}`;
            card.draggable = true;
            card.dataset.id = keyword.id;
            
            const checkbox = `
                <div class="form-check me-3">
                    <input class="form-check-input keyword-checkbox" type="checkbox" value="${keyword.id}" 
                           onchange="handleCheckboxChange(this)" style="width: 18px; height: 18px; cursor: pointer;">
                    <label class="form-check-label" for="checkbox-${keyword.id}" style="cursor: pointer;"></label>
                </div>
            `;
            
            const copyIcon = keyword.tag === 'H1' ? `<i class="fas fa-copy copy-icon" onclick="copyKeyword('${keyword.keyword}')" title="Copy keyword" style="cursor: pointer; margin-right: 8px; color: var(--text-muted);"></i>` : '';
            const keywordText = `<div class="keyword-text" onclick="editKeyword(${keyword.id})" style="cursor: pointer;">${copyIcon}${keyword.keyword}</div>`;
            
            // Add reorder buttons for H2 sections
            let reorderButtons = '';
            if (keyword.tag === 'H2') {
                reorderButtons = `
                    <div class="reorder-buttons me-2">
                        <button class="btn btn-sm btn-outline-secondary reorder-btn" onclick="moveH2Up(${keyword.id})" title="Move H2 up">
                            <i class="fas fa-chevron-up"></i>
                        </button>
                        <button class="btn btn-sm btn-outline-secondary reorder-btn" onclick="moveH2Down(${keyword.id})" title="Move H2 down">
                            <i class="fas fa-chevron-down"></i>
                        </button>
                    </div>
                `;
            }
            
            // Add reorder buttons for H3 sections within H2 containers
            if (keyword.tag === 'H3' && isH2 === false) {
                reorderButtons = `
                    <div class="reorder-buttons me-2">
                        <button class="btn btn-sm btn-outline-secondary reorder-btn" onclick="moveH3Up(${keyword.id})" title="Move H3 up">
                            <i class="fas fa-chevron-up"></i>
                        </button>
                        <button class="btn btn-sm btn-outline-secondary reorder-btn" onclick="moveH3Down(${keyword.id})" title="Move H3 down">
                            <i class="fas fa-chevron-down"></i>
                        </button>
                    </div>
                `;
            }
            
            card.innerHTML = `
                <div class="d-flex align-items-center justify-content-between">
                    <div class="d-flex align-items-center flex-grow-1">
                        ${checkbox}
                        <i class="fas fa-grip-vertical drag-handle me-2"></i>
                        ${reorderButtons}
                        <div class="flex-grow-1">
                            ${keywordText}
                            <div class="mt-1">
                                <span class="badge bg-secondary volume-badge">
                                    <i class="fas fa-chart-line"></i> ${keyword.volume.toLocaleString()}
                                </span>
                                ${keyword.intent ? `<span class="intent-badge ms-2">${keyword.intent}</span>` : ''}
                            </div>
                        </div>
                    </div>
                    <div class="d-flex align-items-center gap-2">
                        <div class="btn-group" role="group">
                            <button type="button" class="btn-tag ${keyword.tag === 'H1' ? 'tag-h1' : 'btn-outline-danger'}" 
                                    onclick="assignTag(${keyword.id}, 'H1')">H1</button>
                            <button type="button" class="btn-tag ${keyword.tag === 'H2' ? 'tag-h2' : 'btn-outline-success'}" 
                                    onclick="assignTag(${keyword.id}, 'H2')">H2</button>
                            <button type="button" class="btn-tag ${keyword.tag === 'H3' ? 'tag-h3' : 'btn-outline-info'}" 
                                    onclick="assignTag(${keyword.id}, 'H3')">H3</button>
                        </div>
                        <button class="btn-remove" onclick="removeKeyword(${keyword.id})">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                </div>
            `;
            
            return card;
        }

        function setupDragAndDrop() {
            const cards = document.querySelectorAll('.keyword-card');
            
            cards.forEach(card => {
                card.addEventListener('dragstart', handleDragStart);
                card.addEventListener('dragend', handleDragEnd);
                card.addEventListener('dragover', handleDragOver);
                card.addEventListener('drop', handleDrop);
            });
            
            // Add drop zones for H2 keywords to accept H3 drops
            const h2Cards = document.querySelectorAll('.keyword-card.tag-h2');
            h2Cards.forEach(h2Card => {
                h2Card.addEventListener('dragover', handleH2DragOver);
                h2Card.addEventListener('drop', handleH2Drop);
            });
            
            // Add H2 section reordering functionality
            setupH2SectionReordering();
        }
        
        function setupH2SectionReordering() {
            const h2Section = document.querySelector('.mb-4:has(.tag-h2)');
            if (!h2Section) return;
            
            const h2Cards = h2Section.querySelectorAll('.keyword-card.tag-h2');
            
            h2Cards.forEach(h2Card => {
                // Make H2 cards draggable for reordering
                h2Card.draggable = true;
                h2Card.addEventListener('dragstart', handleH2SectionDragStart);
                h2Card.addEventListener('dragend', handleH2SectionDragEnd);
                h2Card.addEventListener('dragover', handleH2SectionDragOver);
                h2Card.addEventListener('drop', handleH2SectionDrop);
            });
        }
        
        function handleH2SectionDragStart(e) {
            e.stopPropagation(); // Prevent triggering the regular keyword drag
            e.target.classList.add('dragging');
            e.dataTransfer.setData('text/plain', e.target.dataset.id);
            e.dataTransfer.setData('application/h2-section', 'true'); // Mark as H2 section drag
            
            // Add visual feedback
            e.target.style.opacity = '0.7';
            e.target.style.transform = 'rotate(2deg) scale(1.05)';
        }
        
        function handleH2SectionDragEnd(e) {
            e.target.classList.remove('dragging');
            e.target.style.opacity = '';
            e.target.style.transform = '';
            
            // Remove any drop indicators
            document.querySelectorAll('.keyword-card.tag-h2').forEach(card => {
                card.classList.remove('drag-over');
            });
        }
        
        function handleH2SectionDragOver(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const draggedId = parseInt(e.dataTransfer.getData('text/plain'));
            const targetId = parseInt(e.target.closest('.keyword-card').dataset.id);
            
            // Only allow H2 to H2 reordering
            if (draggedId !== targetId) {
                const h2Card = e.target.closest('.keyword-card.tag-h2');
                if (h2Card) {
                    h2Card.classList.add('drag-over');
                }
            }
        }
        
        function handleH2SectionDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const draggedId = parseInt(e.dataTransfer.getData('text/plain'));
            const targetId = parseInt(e.target.closest('.keyword-card').dataset.id);
            
            // Reset styling
            document.querySelectorAll('.keyword-card.tag-h2').forEach(card => {
                card.classList.remove('drag-over');
            });
            
            if (draggedId !== targetId) {
                reorderH2Sections(draggedId, targetId);
            }
        }
        
        function reorderH2Sections(draggedId, targetId) {
            // Get all H2 keywords
            const h2Keywords = filteredData.filter(kw => kw.tag === 'H2');
            
            // Find the indices of the dragged and target H2 keywords
            const draggedIndex = h2Keywords.findIndex(kw => kw.id === draggedId);
            const targetIndex = h2Keywords.findIndex(kw => kw.id === targetId);
            
            if (draggedIndex !== -1 && targetIndex !== -1) {
                // Reorder H2 keywords
                const [draggedH2] = h2Keywords.splice(draggedIndex, 1);
                h2Keywords.splice(targetIndex, 0, draggedH2);
                
                // Update the order in the main filteredData array
                let currentOrder = 0;
                filteredData.forEach(kw => {
                    if (kw.tag === 'H2') {
                        // Find the H2 keyword in our reordered list
                        const h2Kw = h2Keywords.find(h2 => h2.id === kw.id);
                        if (h2Kw) {
                            kw.order = currentOrder++;
                        }
                    }
                });
                
                // Update backend
                updateBackendData().then(() => {
                    renderKeywords();
                    // Reset generate button since data has changed
                    resetGenerateButton();
                    showNotification('H2 sections reordered successfully', 'success');
                }).catch(error => {
                    console.error('Error updating backend data:', error);
                    showNotification('Error reordering H2 sections. Please try again.', 'error');
                });
            }
        }

        // H2 reordering functions
        function moveH2Up(keywordId) {
            const h2Keywords = filteredData.filter(kw => kw.tag === 'H2').sort((a, b) => a.order - b.order);
            const currentIndex = h2Keywords.findIndex(kw => kw.id === keywordId);
            
            if (currentIndex > 0) {
                // Swap with the previous H2
                const currentH2 = h2Keywords[currentIndex];
                const previousH2 = h2Keywords[currentIndex - 1];
                
                // Update orders
                currentH2.order = previousH2.order;
                previousH2.order = currentH2.order + 1;
                
                // Update backend
                updateBackendData().then(() => {
                    renderKeywords();
                    // Reset generate button since data has changed
                    resetGenerateButton();
                    showNotification('H2 section moved up successfully', 'success');
                }).catch(error => {
                    console.error('Error updating backend data:', error);
                    showNotification('Error moving H2 section. Please try again.', 'error');
                });
            }
        }

        function moveH2Down(keywordId) {
            const h2Keywords = filteredData.filter(kw => kw.tag === 'H2').sort((a, b) => a.order - b.order);
            const currentIndex = h2Keywords.findIndex(kw => kw.id === keywordId);
            
            if (currentIndex < h2Keywords.length - 1) {
                // Swap with the next H2
                const currentH2 = h2Keywords[currentIndex];
                const nextH2 = h2Keywords[currentIndex + 1];
                
                // Update orders
                currentH2.order = nextH2.order;
                nextH2.order = currentH2.order - 1;
                
                // Update backend
                updateBackendData().then(() => {
                    renderKeywords();
                    // Reset generate button since data has changed
                    resetGenerateButton();
                    showNotification('H2 section moved down successfully', 'success');
                }).catch(error => {
                    console.error('Error updating backend data:', error);
                    showNotification('Error moving H2 section. Please try again.', 'error');
                });
            }
        }

        // H3 reordering functions within their parent H2
        function moveH3Up(keywordId) {
            const h3Keyword = filteredData.find(kw => kw.id === keywordId);
            if (!h3Keyword || h3Keyword.tag !== 'H3' || !h3Keyword.parent_id) return;
            
            // Get all H3 keywords that belong to the same parent H2
            const siblingH3s = filteredData.filter(kw => 
                kw.tag === 'H3' && kw.parent_id === h3Keyword.parent_id
            ).sort((a, b) => a.order - b.order);
            
            const currentIndex = siblingH3s.findIndex(kw => kw.id === keywordId);
            
            if (currentIndex > 0) {
                // Swap with the previous H3
                const currentH3 = siblingH3s[currentIndex];
                const previousH3 = siblingH3s[currentIndex - 1];
                
                // Update orders
                currentH3.order = previousH3.order;
                previousH3.order = currentH3.order + 1;
                
                // Update backend
                updateBackendData().then(() => {
                    renderKeywords();
                    // Reset generate button since data has changed
                    resetGenerateButton();
                    showNotification('H3 section moved up successfully', 'success');
                }).catch(error => {
                    console.error('Error updating backend data:', error);
                    showNotification('Error moving H3 section. Please try again.', 'error');
                });
            }
        }

        function moveH3Down(keywordId) {
            const h3Keyword = filteredData.find(kw => kw.id === keywordId);
            if (!h3Keyword || h3Keyword.tag !== 'H3' || !h3Keyword.parent_id) return;
            
            // Get all H3 keywords that belong to the same parent H2
            const siblingH3s = filteredData.filter(kw => 
                kw.tag === 'H3' && kw.parent_id === h3Keyword.parent_id
            ).sort((a, b) => a.order - b.order);
            
            const currentIndex = siblingH3s.findIndex(kw => kw.id === keywordId);
            
            if (currentIndex < siblingH3s.length - 1) {
                // Swap with the next H3
                const currentH3 = siblingH3s[currentIndex];
                const nextH3 = siblingH3s[currentIndex + 1];
                
                // Update orders
                currentH3.order = nextH3.order;
                nextH3.order = currentH3.order - 1;
                
                // Update backend
                updateBackendData().then(() => {
                    renderKeywords();
                    // Reset generate button since data has changed
                    resetGenerateButton();
                    showNotification('H3 section moved down successfully', 'success');
                }).catch(error => {
                    console.error('Error updating backend data:', error);
                    showNotification('Error moving H3 section. Please try again.', 'error');
                });
            }
        }

        function handleDragStart(e) {
            e.target.classList.add('dragging');
            e.dataTransfer.setData('text/plain', e.target.dataset.id);
            
            // Add visual feedback for H3 keywords being dragged
            const keywordId = parseInt(e.target.dataset.id);
            const keyword = filteredData.find(kw => kw.id === keywordId);
            if (keyword && keyword.tag === 'H3') {
                e.target.classList.add('dragging');
                // Show drop zones for H2 keywords
                const h2Cards = document.querySelectorAll('.keyword-card.tag-h2');
                h2Cards.forEach(card => {
                    card.style.border = '2px dashed #333333';
                    card.style.backgroundColor = 'rgba(51, 51, 51, 0.1)';
                });
            }
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            
            // Reset any H2 cards that might have been highlighted
            const h2Cards = document.querySelectorAll('.keyword-card.tag-h2');
            h2Cards.forEach(card => {
                card.style.border = '';
                card.style.backgroundColor = '';
                card.classList.remove('drag-over');
            });
        }

        function handleDragOver(e) {
            e.preventDefault();
        }

        function handleDrop(e) {
            e.preventDefault();
            const draggedId = parseInt(e.dataTransfer.getData('text/plain'));
            const targetId = parseInt(e.target.closest('.keyword-card').dataset.id);
            
            if (draggedId !== targetId) {
                reorderKeywords(draggedId, targetId);
            }
        }
        
        function handleH2DragOver(e) {
            e.preventDefault();
            const draggedId = parseInt(e.dataTransfer.getData('text/plain'));
            const draggedKeyword = filteredData.find(kw => kw.id === draggedId);
            
            // Only allow H3 keywords to be dropped on H2 keywords
            if (draggedKeyword && draggedKeyword.tag === 'H3') {
                const h2Card = e.target.closest('.keyword-card');
                h2Card.classList.add('drag-over');
            }
        }
        
        function handleH2Drop(e) {
            e.preventDefault();
            const draggedId = parseInt(e.dataTransfer.getData('text/plain'));
            const targetId = parseInt(e.target.closest('.keyword-card').dataset.id);
            
            const draggedKeyword = filteredData.find(kw => kw.id === draggedId);
            const targetKeyword = filteredData.find(kw => kw.id === targetId);
            
            // Reset styling
            const h2Card = e.target.closest('.keyword-card');
            h2Card.classList.remove('drag-over');
            
            // Only allow H3 keywords to be dropped on H2 keywords
            if (draggedKeyword && draggedKeyword.tag === 'H3' && targetKeyword && targetKeyword.tag === 'H2') {
                // Assign the H3 keyword to the H2 keyword
                draggedKeyword.parent_id = targetKeyword.id;
                
                // Update backend
                updateBackendData().then(() => {
                    renderKeywords();
                    // Reset generate button since data has changed
                    resetGenerateButton();
                    showNotification(`"${draggedKeyword.keyword}" assigned to "${targetKeyword.keyword}"`, 'success');
                }).catch(error => {
                    console.error('Error updating backend data:', error);
                    showNotification('Error assigning keyword. Please try again.', 'error');
                });
            }
        }

        function reorderKeywords(draggedId, targetId) {
            const draggedIndex = filteredData.findIndex(kw => kw.id === draggedId);
            const targetIndex = filteredData.findIndex(kw => kw.id === targetId);
            
            if (draggedIndex !== -1 && targetIndex !== -1) {
                const [draggedItem] = filteredData.splice(draggedIndex, 1);
                filteredData.splice(targetIndex, 0, draggedItem);
                
                // Update order in backend
                const newOrder = filteredData.map(kw => kw.id);
                
                fetch('/reorder', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ order: newOrder })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                                            renderKeywords();
                    // Reset generate button since data has changed
                    resetGenerateButton();
                    showNotification('Keywords reordered successfully', 'success');
                    } else {
                        showNotification(data.error, 'error');
                    }
                })
                .catch(error => {
                    showNotification('Error reordering keywords: ' + error.message, 'error');
                });
            }
        }

        function showControls() {
            document.getElementById('controlsPanel').style.display = 'block';
            document.getElementById('keywordsContainer').style.display = 'block';
        }

        function testConnection() {
            console.log('Testing connection...'); // Debug log
            fetch('/test')
                .then(response => response.json())
                .then(data => {
                    console.log('Test response:', data); // Debug log
                    showNotification('Connection test successful!', 'success');
                })
                .catch(error => {
                    console.error('Test error:', error); // Debug log
                    showNotification('Connection test failed: ' + error.message, 'error');
                });
        }
        
        function testHandleFormatting() {
            console.log('Testing handle formatting...');
            const testCases = [
                'almond nails',
                'ALMOND NAILS',
                'almond  nails',
                'almond-nails',
                'almond nails!',
                'almond nails 123',
                '  almond nails  ',
                'almond--nails'
            ];
            
            testCases.forEach(testCase => {
                const result = formatHandle(testCase);
                console.log(`"${testCase}" -> "${result}"`);
            });
            
            // Test the actual input field
            const handleInput = document.getElementById('projectHandle');
            if (handleInput) {
                console.log('Testing with actual input field...');
                handleInput.value = 'test almond nails';
                console.log('Before formatting:', handleInput.value);
                const formatted = formatHandle(handleInput.value);
                console.log('After formatting:', formatted);
                handleInput.value = formatted;
                console.log('Input field value after setting:', handleInput.value);
                
                // Test the input event by dispatching it
                console.log('Testing input event dispatch...');
                const inputEvent = new Event('input', { bubbles: true });
                handleInput.dispatchEvent(inputEvent);
            }
            
            showNotification('Handle formatting test completed. Check console for results.', 'success');
        }

        function handleCheckboxChange(checkbox) {
            // Add/remove selected class to keyword text
            const keywordCard = checkbox.closest('.keyword-card');
            const keywordText = keywordCard.querySelector('.keyword-text');
            if (checkbox.checked) {
                keywordText.classList.add('selected');
                console.log('Added selected class to:', keywordText.textContent);
                console.log('Element classes:', keywordText.className);
                console.log('Parent card classes:', keywordCard.className);
            } else {
                keywordText.classList.remove('selected');
                console.log('Removed selected class from:', keywordText.textContent);
            }
            
            updateRemoveButton();
        }
        
        function updateRemoveButton() {
            const checkedBoxes = document.querySelectorAll('.keyword-checkbox:checked');
            const removeBtn = document.getElementById('removeH2Btn');
            
            if (checkedBoxes.length > 0) {
                removeBtn.style.display = 'inline-block';
                removeBtn.innerHTML = `<i class="fas fa-trash"></i> Remove Selected (${checkedBoxes.length})`;
            } else {
                removeBtn.style.display = 'none';
            }
        }
        
        function removeSelectedH2s() {
            const checkedBoxes = document.querySelectorAll('.keyword-checkbox:checked');
            const selectedIds = Array.from(checkedBoxes).map(cb => parseInt(cb.value));
            
            if (selectedIds.length === 0) return;
            
            console.log('Removing keywords with IDs:', selectedIds);
            console.log('Before removal - filteredData length:', filteredData.length);
            
            // Get the keywords that will be removed for debugging
            const keywordsToRemove = filteredData.filter(kw => selectedIds.includes(kw.id));
            console.log('Keywords to remove:', keywordsToRemove.map(kw => ({ id: kw.id, keyword: kw.keyword, tag: kw.tag })));
            
            // Remove from filtered data (this is what we're working with)
            filteredData = filteredData.filter(kw => !selectedIds.includes(kw.id));
            
            console.log('After removal - filteredData length:', filteredData.length);
            console.log('Remaining keywords:', filteredData.map(kw => ({ id: kw.id, keyword: kw.keyword, tag: kw.tag })));
            
            // Update order
            for (let i = 0; i < filteredData.length; i++) {
                filteredData[i].order = i;
            }
            
            // Update backend with the new data and wait for completion
            updateBackendData().then(() => {
                renderKeywords();
                showNotification(`Removed ${selectedIds.length} keywords`, 'success');
            }).catch(error => {
                console.error('Error updating backend data:', error);
                showNotification('Error updating data. Please try again.', 'error');
            });
        }
        
        function updateBackendData() {
            // Send updated data to backend (use filteredData since that's what we're working with)
            return fetch('/update_data', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ data: filteredData })
            })
            .then(response => response.json())
            .then(data => {
                if (!data.success) {
                    console.error('Failed to update backend data');
                    throw new Error('Failed to update backend data');
                }
                return data;
            })
            .catch(error => {
                console.error('Error updating backend data:', error);
                throw error;
            });
        }
        
        function editKeyword(keywordId) {
            const keyword = filteredData.find(kw => kw.id === keywordId);
            if (!keyword) return;
            
            // Find the keyword text element
            const keywordElement = document.querySelector(`[data-id="${keywordId}"] .keyword-text`);
            if (!keywordElement) return;
            
            const originalText = keyword.keyword;
            
            // Create input field
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'edit-input';
            input.value = originalText;
            
            // Replace text with input
            keywordElement.innerHTML = '';
            keywordElement.appendChild(input);
            keywordElement.classList.add('editing');
            
            // Focus and select all text
            input.focus();
            input.select();
            
            // Save function
            const saveEdit = () => {
                let newValue = input.value.trim();
                if (newValue && newValue !== originalText) {
                    // Capitalize first letter of each word for H1 and H2
                    if (keyword.tag === 'H1' || keyword.tag === 'H2') {
                        newValue = newValue.toLowerCase().replace(/\b\w/g, l => l.toUpperCase());
                    }
                    
                    keyword.keyword = newValue;
                    renderKeywords();
                    // Reset generate button since data has changed
                    resetGenerateButton();
                    showNotification('Keyword updated', 'success');
                } else {
                    // Restore original if empty or unchanged
                    keywordElement.innerHTML = originalText;
                    keywordElement.classList.remove('editing');
                }
            };
            
            // Cancel function
            const cancelEdit = () => {
                keywordElement.innerHTML = originalText;
                keywordElement.classList.remove('editing');
            };
            
            // Event listeners
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    saveEdit();
                } else if (e.key === 'Escape') {
                    cancelEdit();
                }
            });
            
            // Auto-save on blur (when input loses focus)
            input.addEventListener('blur', () => {
                saveEdit();
            });
            
            // Click outside to save (only if not already saved by blur)
            const handleClickOutside = (e) => {
                if (!keywordElement.contains(e.target)) {
                    // Only save if the element is still in editing mode
                    if (keywordElement.classList.contains('editing')) {
                        saveEdit();
                    }
                    document.removeEventListener('click', handleClickOutside);
                }
            };
            
            // Delay to prevent immediate trigger
            setTimeout(() => {
                document.addEventListener('click', handleClickOutside);
            }, 100);
        }
        
        function toggleSelectAll() {
            const selectAllCheckbox = document.getElementById('selectAllCheckbox');
            const allCheckboxes = document.querySelectorAll('.keyword-checkbox');
            
            allCheckboxes.forEach(checkbox => {
                checkbox.checked = selectAllCheckbox.checked;
                // Add/remove selected class to keyword text
                const keywordCard = checkbox.closest('.keyword-card');
                const keywordText = keywordCard.querySelector('.keyword-text');
                if (checkbox.checked) {
                    keywordText.classList.add('selected');
                } else {
                    keywordText.classList.remove('selected');
                }
            });
            
            updateRemoveButton();
        }
        
        function addNewH2() {
            const newKeyword = prompt('Enter new H2 keyword:');
            if (newKeyword && newKeyword.trim() !== '') {
                // Capitalize first letter of each word for H2
                let capitalizedKeyword = newKeyword.trim().toLowerCase().replace(/\b\w/g, l => l.toUpperCase());
                
                const newId = Math.max(...filteredData.map(kw => kw.id), 0) + 1;
                const newH2 = {
                    id: newId,
                    keyword: capitalizedKeyword,
                    volume: 0,
                    intent: '',
                    difficulty: 0,
                    cpc: 0,
                    tag: 'H2',
                    order: filteredData.length
                };
                
                filteredData.push(newH2);
                
                renderKeywords();
                // Reset generate button since data has changed
                resetGenerateButton();
                showNotification('New H2 keyword added', 'success');
            }
        }
        


        function searchKeywords() {
            const searchTerm = document.getElementById('keywordSearch').value.toLowerCase().trim();
            const searchResults = document.getElementById('searchResults');
            const searchResultsList = document.getElementById('searchResultsList');
            const searchCount = document.getElementById('searchCount');
            
            if (searchTerm === '') {
                searchResults.style.display = 'none';
                return;
            }
            
            // Search in filteredData
            const results = filteredData.filter(keyword => 
                keyword.keyword.toLowerCase().includes(searchTerm)
            );
            
            // Display results
            searchResultsList.innerHTML = '';
            
            if (results.length === 0) {
                searchResultsList.innerHTML = '<div class="p-3 text-center text-muted">No keywords found matching your search.</div>';
            } else {
                results.forEach(keyword => {
                    const resultItem = createSearchResultItem(keyword);
                    searchResultsList.appendChild(resultItem);
                });
            }
            
            searchCount.textContent = results.length;
            searchResults.style.display = 'block';
        }
        
        function createSearchResultItem(keyword) {
            const item = document.createElement('div');
            item.className = 'search-result-item';
            
            const tagClass = keyword.tag ? keyword.tag.toLowerCase() : 'untagged';
            const tagText = keyword.tag || 'Untagged';
            
            item.innerHTML = `
                <div class="search-result-info">
                    <div class="search-result-keyword">${keyword.keyword}</div>
                    <div class="search-result-details">
                        Volume: ${keyword.volume.toLocaleString()} | 
                        Difficulty: ${keyword.difficulty} | 
                        CPC: $${keyword.cpc} | 
                        Intent: ${keyword.intent || 'N/A'}
                    </div>
                </div>
                <div class="search-result-actions">
                    <span class="search-result-tag ${tagClass}">${tagText}</span>
                    <button class="btn btn-sm btn-outline-danger" onclick="removeKeywordFromSearch(${keyword.id})" title="Remove keyword">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            `;
            
            return item;
        }
        
        function removeKeywordFromSearch(keywordId) {
            // Remove from filteredData
            filteredData = filteredData.filter(kw => kw.id !== keywordId);
            
            // Update order
            for (let i = 0; i < filteredData.length; i++) {
                filteredData[i].order = i;
            }
            
            // Update backend
            updateBackendData().then(() => {
                // Refresh search results
                searchKeywords();
                // Refresh main keyword list
                renderKeywords();
                // Reset generate button since data has changed
                resetGenerateButton();
                showNotification('Keyword removed successfully', 'success');
            }).catch(error => {
                console.error('Error updating backend data:', error);
                showNotification('Error removing keyword. Please try again.', 'error');
            });
        }
        
        function clearSearch() {
            document.getElementById('keywordSearch').value = '';
            document.getElementById('searchResults').style.display = 'none';
        }
        
        // Add event listeners to hero section fields to reset generate button when changed
        document.addEventListener('DOMContentLoaded', function() {
            const heroFields = ['heroTagline', 'heroCTA', 'heroImageUrl', 'heroAltText'];
            const identifierFields = ['projectTags']; // Remove projectHandle from here since we handle it separately
            
            [...heroFields, ...identifierFields].forEach(fieldId => {
                const field = document.getElementById(fieldId);
                if (field) {
                    field.addEventListener('input', resetGenerateButton);
                }
            });
            
            // Handle heroCTALink separately since it's now a select element
            const ctaLinkField = document.getElementById('heroCTALink');
            if (ctaLinkField) {
                ctaLinkField.addEventListener('change', resetGenerateButton);
            }
            
            // Add real-time formatting for handle and tags
            setupRealTimeFormatting();
            
            // Setup CTA link dropdown functionality
            setupCTALinkDropdown();
            
            // Test the formatting function
            console.log('Testing formatHandle function:');
            console.log('"almond nails" ->', formatHandle('almond nails'));
            console.log('"ALMOND NAILS" ->', formatHandle('ALMOND NAILS'));
            console.log('"almond  nails" ->', formatHandle('almond  nails'));
            console.log('"almond-nails" ->', formatHandle('almond-nails'));
            
            // Test space replacement specifically
            console.log('Testing space replacement:');
            const testSpace = 'test space';
            console.log(`"${testSpace}" -> "${testSpace.replace(/\s+/g, '-')}"`);
            console.log(`"${testSpace}" -> "${formatHandle(testSpace)}"`);
            
            // Test trailing space specifically
            console.log('Testing trailing space:');
            const testTrailingSpace = 'test ';
            console.log(`"${testTrailingSpace}" -> "${formatHandle(testTrailingSpace)}"`);
            
            // Test space in middle
            console.log('Testing space in middle:');
            const testMiddleSpace = 'test space test';
            console.log(`"${testMiddleSpace}" -> "${formatHandle(testMiddleSpace)}"`);
        });
        
        function setupRealTimeFormatting() {
            const handleInput = document.getElementById('projectHandle');
            const tagsInput = document.getElementById('projectTags');
            
            console.log('Setting up real-time formatting...');
            console.log('Handle input found:', !!handleInput);
            console.log('Tags input found:', !!tagsInput);
            
            if (handleInput) {
                // Primary event listener for real-time formatting
                handleInput.addEventListener('input', function(e) {
                    console.log('Handle input event triggered');
                    const originalValue = e.target.value;
                    console.log('Original value:', originalValue);
                    const formattedHandle = formatHandle(originalValue);
                    console.log('Formatted handle:', formattedHandle);
                    
                    // Only update if the formatted value is different to avoid cursor jumping
                    if (formattedHandle !== originalValue) {
                        const cursorPosition = e.target.selectionStart;
                        
                        e.target.value = formattedHandle;
                        
                        // For space-to-hyphen conversion, keep cursor in same position
                        if (originalValue.includes(' ') && formattedHandle.includes('-')) {
                            e.target.setSelectionRange(cursorPosition, cursorPosition);
                        } else {
                            // For other cases, try to maintain relative position
                            const newPosition = Math.min(cursorPosition, formattedHandle.length);
                            e.target.setSelectionRange(newPosition, newPosition);
                        }
                        
                        // Add visual feedback
                        e.target.style.backgroundColor = '#e8f5e8';
                        setTimeout(() => {
                            e.target.style.backgroundColor = '';
                        }, 200);
                    }
                    
                    // Reset generate button
                    resetGenerateButton();
                });
                
                // Also format on blur to ensure it happens when user leaves the field
                handleInput.addEventListener('blur', function(e) {
                    const originalValue = e.target.value;
                    const formattedHandle = formatHandle(originalValue);
                    
                    if (formattedHandle !== originalValue) {
                        e.target.value = formattedHandle;
                        resetGenerateButton();
                    }
                });
            }
            
            if (tagsInput) {
                tagsInput.addEventListener('input', function(e) {
                    console.log('Tags input event triggered');
                    // Allow manual editing of tags - no automatic syncing
                    resetGenerateButton();
                });
            }
        }
        
        function formatHandle(value) {
            console.log('formatHandle called with:', value);
            if (!value || typeof value !== 'string') {
                console.log('formatHandle: Invalid input, returning empty string');
                return '';
            }
            
            // Convert to lowercase and replace spaces with hyphens
            let formatted = value.toLowerCase();
            console.log('After toLowerCase:', formatted);
            
            // Replace multiple spaces with single hyphen
            formatted = formatted.replace(/\s+/g, '-');
            console.log('After space replacement:', formatted);
            
            // Remove any characters that aren't letters, numbers, or hyphens
            formatted = formatted.replace(/[^a-z0-9-]/g, '');
            console.log('After character filtering:', formatted);
            
            // Remove consecutive hyphens
            formatted = formatted.replace(/-+/g, '-');
            console.log('After consecutive hyphen removal:', formatted);
            
            // Remove leading hyphens but preserve trailing hyphens that result from space conversion
            formatted = formatted.replace(/^-+/, '');
            console.log('After leading hyphen removal:', formatted);
            
            console.log('formatHandle final result:', formatted);
            return formatted;
        }
        
        function syncTagsWithHandle(handleValue) {
            console.log('syncTagsWithHandle called with:', handleValue);
            const tagsInput = document.getElementById('projectTags');
            if (!tagsInput || !handleValue) {
                console.log('Tags input not found or handle value empty');
                return;
            }
            
            // Convert handle back to space-separated format for tags
            const tagsValue = handleValue.replace(/-+/g, ' ').trim();
            console.log('Converted tags value:', tagsValue);
            
            // Only update if the current tags value is different
            if (tagsInput.value !== tagsValue) {
                console.log('Updating tags input from:', tagsInput.value, 'to:', tagsValue);
                tagsInput.value = tagsValue;
            } else {
                console.log('Tags value unchanged');
            }
        }
        
        function setupCTALinkDropdown() {
            const ctaLinkSelect = document.getElementById('heroCTALink');
            if (!ctaLinkSelect) {
                console.log('CTA Link select not found');
                return;
            }
            
            ctaLinkSelect.addEventListener('change', function(e) {
                const selectedValue = e.target.value;
                console.log('CTA Link selected:', selectedValue);
                
                if (selectedValue === 'custom') {
                    // Replace the select with a text input for custom URL
                    const parentDiv = ctaLinkSelect.parentElement;
                    const label = parentDiv.querySelector('label');
                    const small = parentDiv.querySelector('small');
                    
                    // Create text input
                    const textInput = document.createElement('input');
                    textInput.type = 'text';
                    textInput.className = 'form-control';
                    textInput.id = 'heroCTALink';
                    textInput.placeholder = 'Enter custom URL (e.g., https://example.com)';
                    textInput.required = true;
                    
                    // Add event listener to reset generate button
                    textInput.addEventListener('input', resetGenerateButton);
                    
                    // Replace select with input
                    ctaLinkSelect.replaceWith(textInput);
                    
                    // Update help text
                    if (small) {
                        small.textContent = 'Enter your custom URL';
                    }
                    
                    // Focus on the new input
                    textInput.focus();
                } else if (selectedValue) {
                    // Reset generate button when a predefined option is selected
                    resetGenerateButton();
                }
            });
        }
        
        function handleGenerateOrDownload() {
            const generateBtn = document.getElementById('generateBtn');
            
            // Check if content has been generated (button is green with "Download" text)
            if (generateBtn.classList.contains('btn-success') && generateBtn.innerHTML.includes('Download')) {
                // Download the generated file
                const filename = generateBtn.dataset.generatedFilename;
                if (filename) {
                    downloadGeneratedContent(filename);
                } else {
                    showNotification('No generated file found. Please generate content first.', 'error');
                }
            } else {
                // Generate content
                generateContent();
            }
        }
        
        function resetGenerateButton() {
            const generateBtn = document.getElementById('generateBtn');
            generateBtn.innerHTML = '<i class="fas fa-magic"></i> Generate Content';
            generateBtn.className = 'btn btn-primary';
            generateBtn.disabled = false;
            delete generateBtn.dataset.generatedFilename;
        }
        
        function generateContent() {
            const generateBtn = document.getElementById('generateBtn');
            const originalText = generateBtn.innerHTML;
            
            // Show loading state
            generateBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Generating...';
            generateBtn.disabled = true;
            
            console.log('Generating content for filteredData length:', filteredData.length);
            
            // Get identifier data from form inputs
            const handle = document.getElementById('projectHandle').value.trim();
            const tags = document.getElementById('projectTags').value.trim();
            
            // Get hero section data from form inputs
            const heroTagline = document.getElementById('heroTagline').value.trim();
            const heroCTA = document.getElementById('heroCTA').value.trim();
            const heroCTALink = document.getElementById('heroCTALink').value.trim();
            const heroImageUrl = document.getElementById('heroImageUrl').value.trim();
            const heroAltText = document.getElementById('heroAltText').value.trim();
            
            // Validate hero section data
            if (!heroTagline || !heroCTA || !heroCTALink || !heroImageUrl || !heroAltText) {
                showNotification('Please fill in all hero section fields (Tagline, CTA Text, CTA Link, Hero Image URL, and Alt Text Image)', 'error');
                generateBtn.innerHTML = originalText;
                generateBtn.disabled = false;
                return;
            }
            
            // Validate that all selected images have been uploaded to Cloudinary
            if (selectedImages.length > 0) {
                const unuploadedImages = selectedImages.filter(image => !image.cloudinaryUrl);
                if (unuploadedImages.length > 0) {
                    showNotification('You did not upload the images to Cloudinary. Please upload all selected images before generating content.', 'error');
                    generateBtn.innerHTML = originalText;
                    generateBtn.disabled = false;
                    return;
                }
            }
            
            // Store identifier data for later use in the final output
            const identifierData = {
                handle: handle || 'default-handle',
                tags: tags || 'default-tags'
            };
            
            // Store hero section data
            const heroData = {
                tagline: heroTagline,
                cta_text: heroCTA,
                cta_link: heroCTALink,
                image_url: heroImageUrl,
                alt_text: heroAltText
            };
            
            // Get handle for consistent image naming
            const projectHandle = document.getElementById('projectHandle').value.trim();
            
            // Get images data (Cloudinary URLs with alt text)
            const imagesData = selectedImages
                .filter(image => image.cloudinaryUrl)
                .map((image, index) => {
                    // Use handle as filename for all images, with index for uniqueness
                    let altText = image.filename; // Default fallback
                    if (projectHandle) {
                        altText = selectedImages.length > 1 ? `${projectHandle}_${index + 1}` : projectHandle;
                    }
                    return {
                        url: image.cloudinaryUrl,
                        alt: altText
                    };
                });
            
            // Debug: Log selected images and images data
            console.log('Selected Images:', selectedImages);
            console.log('Images Data being sent:', imagesData);
            
            // First, ensure backend is synced with the data we want to generate content for
            updateBackendData().then(() => {
                // Then generate content with a small delay to ensure backend has processed the update
                setTimeout(() => {
                    fetch('/generate_content', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ 
                            data: filteredData,
                            identifier: identifierData,
                            hero: heroData,
                            images: imagesData
                        })
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            // Change button to green "Download" state
                            generateBtn.innerHTML = '<i class="fas fa-download"></i> Download';
                            generateBtn.className = 'btn btn-success';
                            generateBtn.disabled = false;
                            
                            // Store the generated filename for download
                            generateBtn.dataset.generatedFilename = data.filename;
                            
                            // Show success message with file location
                            const successMessage = `âœ… Content generated successfully! 
File saved to: D:/articles/nails/${data.filename}`;
                            showNotification(successMessage, 'success');
                            
                            // Show summary in console
                            console.log('Generated Content Summary:', data.summary);
                            console.log('File saved to:', data.file_path);
                            
                            // Show summary in a more detailed notification
                            const summary = data.summary;
                            const summaryText = `
ðŸ“„ Content Summary:
â€¢ Title: ${summary.title}
â€¢ Meta Description: ${summary.meta_description}
â€¢ Hero Tagline: ${summary.hero_tagline}
â€¢ Hero CTA: ${summary.hero_cta}
â€¢ Hero CTA Link: ${summary.hero_cta_link}
â€¢ H2 Sections: ${summary.h2_sections}
â€¢ FAQs Generated: ${summary.faqs_generated}
â€¢ Images Included: ${summary.images_count}
â€¢ File Location: D:/articles/nails/${data.filename}
                            `;
                            showNotification(summaryText, 'success');
                            
                            // Automatically download the generated JSON file
                            downloadGeneratedContent(data.filename);
                        } else {
                            showNotification('Error generating content: ' + data.error, 'error');
                            // Reset button state on error
                            generateBtn.innerHTML = originalText;
                            generateBtn.className = 'btn btn-primary';
                            generateBtn.disabled = false;
                        }
                    })
                    .catch(error => {
                        showNotification('Error generating content: ' + error.message, 'error');
                        // Reset button state on error
                        generateBtn.innerHTML = originalText;
                        generateBtn.className = 'btn btn-primary';
                        generateBtn.disabled = false;
                    });
                }, 200); // 200ms delay after backend sync
            }).catch(error => {
                console.error('Error syncing with backend before content generation:', error);
                showNotification('Error syncing data before content generation. Please try again.', 'error');
                // Reset button state
                generateBtn.innerHTML = originalText;
                generateBtn.disabled = false;
            });
        }
        
        function downloadGeneratedContent(filename) {
            // Create a download link for the generated file
            const link = document.createElement('a');
            link.href = `/download_generated/${filename}`;
            link.download = filename;
            link.style.display = 'none';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            showNotification(`ðŸ“¥ File downloaded: ${filename}`, 'success');
        }
        

        
        function copyKeyword(keyword) {
            // Copy the keyword to clipboard
            navigator.clipboard.writeText(keyword).then(() => {
                // Find the copy icon and add visual feedback
                const copyIcons = document.querySelectorAll('.copy-icon');
                copyIcons.forEach(icon => {
                    if (icon.parentElement.textContent.includes(keyword)) {
                        icon.classList.add('copied');
                        // Remove the copied class after animation
                        setTimeout(() => {
                            icon.classList.remove('copied');
                        }, 500);
                    }
                });
                
                // Show success notification
                showNotification(`âœ… Copied: "${keyword}"`, 'success');
            }).catch(err => {
                console.error('Failed to copy keyword:', err);
                showNotification('âŒ Failed to copy keyword', 'error');
            });
        }

        function showNotification(message, type) {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = `alert alert-${type === 'error' ? 'danger' : 'success'} alert-dismissible fade show position-fixed`;
            notification.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 300px;';
            notification.innerHTML = `
                ${message}
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            `;
            
            document.body.appendChild(notification);
            
            // Auto remove after 5 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.remove();
                }
            }, 5000);
        }

        // Image Upload Functions
        let selectedImages = [];
        let pexelsApiKey = 'YOUR_PEXELS_API_KEY'; // Replace with your Pexels API key

        function showUploadOption(option) {
            // Hide all upload sections
            document.getElementById('localUploadSection').style.display = 'none';
            document.getElementById('pexelsSearchSection').style.display = 'none';
            
            // Show selected section
            if (option === 'local') {
                document.getElementById('localUploadSection').style.display = 'block';
                // Add event listener for file input
                document.getElementById('imageFileInput').addEventListener('change', handleLocalImageUpload);
            } else if (option === 'pexels') {
                document.getElementById('pexelsSearchSection').style.display = 'block';
                // Add event listener for Enter key on Pexels search input
                const pexelsSearchInput = document.getElementById('pexelsSearchInput');
                if (pexelsSearchInput) {
                    pexelsSearchInput.addEventListener('keydown', function(e) {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            searchPexels();
                        }
                    });
                }
            }
        }

        function handleLocalImageUpload(event) {
            const files = event.target.files;
            // Get project handle for consistent naming
            const projectHandle = document.getElementById('projectHandle').value.trim();
            
            for (let file of files) {
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const defaultFilename = projectHandle || file.name.replace(/\.[^/.]+$/, ""); // Use handle or original name
                        const imageData = {
                            id: Date.now() + Math.random(),
                            type: 'local',
                            file: file,
                            dataUrl: e.target.result,
                            filename: defaultFilename,
                            originalName: file.name
                        };
                        addSelectedImage(imageData);
                    };
                    reader.readAsDataURL(file);
                }
            }
        }

        let currentPexelsPage = 1;
        let currentPexelsQuery = '';
        let allPexelsImages = [];

        function searchPexels() {
            const query = document.getElementById('pexelsSearchInput').value.trim();
            if (!query) {
                showNotification('Please enter a search term', 'error');
                return;
            }

            // Reset pagination for new search
            currentPexelsPage = 1;
            currentPexelsQuery = query;
            allPexelsImages = [];

            const resultsContainer = document.getElementById('pexelsResults');
            resultsContainer.innerHTML = '<div class="col-12 text-center"><i class="fas fa-spinner fa-spin"></i> Searching...</div>';

            fetch(`/search_pexels?query=${encodeURIComponent(query)}&page=${currentPexelsPage}`)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        allPexelsImages = data.images;
                        displayPexelsResults(allPexelsImages);
                        
                        // Show/hide load more button
                        const loadMoreSection = document.getElementById('loadMoreSection');
                        if (data.next_page) {
                            loadMoreSection.style.display = 'block';
                        } else {
                            loadMoreSection.style.display = 'none';
                        }
                    } else {
                        showNotification(data.error, 'error');
                    }
                })
                .catch(error => {
                    showNotification('Error searching Pexels: ' + error.message, 'error');
                });
        }

        function loadMorePexels() {
            if (!currentPexelsQuery) {
                showNotification('No active search query', 'error');
                return;
            }

            currentPexelsPage++;
            const loadMoreBtn = document.querySelector('#loadMoreSection button');
            const originalText = loadMoreBtn.innerHTML;
            loadMoreBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Loading...';
            loadMoreBtn.disabled = true;

            fetch(`/search_pexels?query=${encodeURIComponent(currentPexelsQuery)}&page=${currentPexelsPage}`)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Add new images to existing ones
                        allPexelsImages = allPexelsImages.concat(data.images);
                        displayPexelsResults(allPexelsImages);
                        
                        // Show/hide load more button
                        const loadMoreSection = document.getElementById('loadMoreSection');
                        if (data.next_page) {
                            loadMoreSection.style.display = 'block';
                        } else {
                            loadMoreSection.style.display = 'none';
                        }
                    } else {
                        showNotification(data.error, 'error');
                    }
                })
                .catch(error => {
                    showNotification('Error loading more images: ' + error.message, 'error');
                })
                .finally(() => {
                    loadMoreBtn.innerHTML = originalText;
                    loadMoreBtn.disabled = false;
                });
        }

        function displayPexelsResults(images) {
            const resultsContainer = document.getElementById('pexelsResults');
            resultsContainer.innerHTML = '';

            if (images.length === 0) {
                resultsContainer.innerHTML = '<div class="col-12 text-center">No images found</div>';
                return;
            }

            images.forEach(image => {
                const col = document.createElement('div');
                col.className = 'col-md-3 mb-3';
                col.innerHTML = `
                    <div class="pexels-image-card" onclick="selectPexelsImage('${image.id}', '${image.src.large}', '${image.photographer}')">
                        <div class="image-wrapper">
                            <img src="${image.src.large}" alt="${image.alt}" loading="lazy">
                        </div>
                        <div class="mt-2">
                            <small class="text-muted">By ${image.photographer}</small>
                        </div>
                    </div>
                `;
                resultsContainer.appendChild(col);
            });
        }

        function selectPexelsImage(imageId, imageUrl, photographer) {
            // Get project handle for consistent naming
            const projectHandle = document.getElementById('projectHandle').value.trim();
            const defaultFilename = projectHandle || `pexels-${imageId}`;
            
            const imageData = {
                id: imageId,
                type: 'pexels',
                url: imageUrl,
                photographer: photographer,
                filename: defaultFilename,
                originalName: `${defaultFilename}.jpg`
            };
            addSelectedImage(imageData);
        }

        function addSelectedImage(imageData) {
            // If this is a handle-based filename, always add an index to make it unique
            const projectHandle = document.getElementById('projectHandle').value.trim();
            if (imageData.filename === projectHandle) {
                const existingImagesWithHandle = selectedImages.filter(img => 
                    img.filename === projectHandle || img.filename.startsWith(projectHandle + '_')
                );
                // Always add an index, starting from 1 for the first image
                imageData.filename = `${projectHandle}_${existingImagesWithHandle.length + 1}`;
            }
            
            selectedImages.push(imageData);
            updateSelectedImagesDisplay();
            document.getElementById('selectedImagesSection').style.display = 'block';
        }

        function updateSelectedImagesDisplay() {
            const container = document.getElementById('selectedImagesList');
            container.innerHTML = '';

            selectedImages.forEach((image, index) => {
                const col = document.createElement('div');
                col.className = 'col-md-4 mb-3';
                
                const imageSrc = image.type === 'local' ? image.dataUrl : image.url;
                
                col.innerHTML = `
                    <div class="selected-image-item">
                        <div class="image-wrapper">
                            <img src="${imageSrc}" alt="Selected image">
                        </div>
                        <div class="mb-2">
                            <label class="form-label">Filename:</label>
                            <input type="text" class="form-control image-filename-input" 
                                   value="${image.filename}" 
                                   onchange="updateImageFilename(${index}, this.value)">
                        </div>
                        <button class="btn btn-sm btn-danger" onclick="removeSelectedImage(${index})">
                            <i class="fas fa-trash"></i> Remove
                        </button>
                    </div>
                `;
                container.appendChild(col);
            });
        }

        function updateImageFilename(index, filename) {
            selectedImages[index].filename = filename;
        }

        function removeSelectedImage(index) {
            selectedImages.splice(index, 1);
            updateSelectedImagesDisplay();
            
            if (selectedImages.length === 0) {
                document.getElementById('selectedImagesSection').style.display = 'none';
            }
        }

        function applyBulkFileName() {
            const bulkFileName = document.getElementById('bulkFileName').value.trim();
            if (!bulkFileName) {
                showNotification('Please enter a filename', 'error');
                return;
            }

            selectedImages.forEach((image, index) => {
                image.filename = bulkFileName + (selectedImages.length > 1 ? `-${index + 1}` : '');
            });
            updateSelectedImagesDisplay();
            showNotification('Filename applied to all images', 'success');
        }

        function uploadToCloudinary() {
            if (selectedImages.length === 0) {
                showNotification('No images selected', 'error');
                return;
            }

            const uploadPromises = selectedImages.map(image => {
                return new Promise((resolve, reject) => {
                    if (image.type === 'local') {
                        // Upload local file to Cloudinary
                        uploadLocalImageToCloudinary(image, resolve, reject);
                    } else {
                        // Download Pexels image and upload to Cloudinary
                        uploadPexelsImageToCloudinary(image, resolve, reject);
                    }
                });
            });

            Promise.all(uploadPromises)
                .then(results => {
                    showNotification('All images uploaded successfully!', 'success');
                    console.log('Upload results:', results);
                })
                .catch(error => {
                    showNotification('Error uploading images: ' + error.message, 'error');
                });
        }

        function uploadLocalImageToCloudinary(image, resolve, reject) {
            const formData = new FormData();
            formData.append('file', image.file);
            
            // Use the image.filename which now contains the indexed version
            const finalFilename = image.filename;
            formData.append('filename', finalFilename);

            console.log('Uploading to Cloudinary:', image.filename);
            
            fetch('/upload_to_cloudinary', {
                method: 'POST',
                body: formData
            })
            .then(response => {
                console.log('Cloudinary upload response status:', response.status);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                console.log('Cloudinary upload response:', data);
                if (data.success) {
                    // Set the cloudinaryUrl in the selectedImages array
                    const imageIndex = selectedImages.findIndex(img => img === image);
                    if (imageIndex !== -1) {
                        selectedImages[imageIndex].cloudinaryUrl = data.url;
                    }
                    resolve(data.url);
                } else {
                    reject(new Error(data.error));
                }
            })
            .catch(error => {
                console.error('Cloudinary upload error:', error);
                reject(error);
            });
        }

        function uploadPexelsImageToCloudinary(image, resolve, reject) {
            // Use the image.filename which now contains the indexed version
            const finalFilename = image.filename;
            
            console.log('Uploading Pexels image to Cloudinary:', finalFilename);
            
            fetch('/upload_pexels_to_cloudinary', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    imageUrl: image.url,
                    filename: finalFilename
                })
            })
            .then(response => {
                console.log('Pexels upload response status:', response.status);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                console.log('Pexels upload response:', data);
                if (data.success) {
                    // Set the cloudinaryUrl in the selectedImages array
                    const imageIndex = selectedImages.findIndex(img => img === image);
                    if (imageIndex !== -1) {
                        selectedImages[imageIndex].cloudinaryUrl = data.url;
                    }
                    resolve(data.url);
                } else {
                    reject(new Error(data.error));
                }
            })
            .catch(error => {
                console.error('Pexels upload error:', error);
                reject(error);
            });
        }
    </script>
</body>
</html>
