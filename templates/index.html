<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Keyword Hierarchy Dashboard</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Airy, modern theme with improved typography */
        :root {
            --bg-primary: #fafbfc;          /* Very light blue-grey background */
            --bg-secondary: #ffffff;        /* Pure white secondary */
            --bg-card: #ffffff;             /* White card background */
            --text-primary: #2d3748;        /* Dark blue-grey text */
            --text-secondary: #4a5568;      /* Medium blue-grey text */
            --text-muted: #718096;          /* Light blue-grey text */
            --border-color: #e2e8f0;        /* Very light grey border */
            --accent-primary: #3182ce;      /* Modern blue accent */
            --accent-secondary: #38a169;    /* Modern green accent */
            --accent-tertiary: #ed8936;     /* Modern orange accent */
            --accent-cool: #3182ce;         /* Cool blue accent (was missing) */
            --success-color: #38a169;       /* Modern green */
            --warning-color: #ed8936;       /* Modern orange */
            --danger-color: #e53e3e;        /* Modern red */
            --h1-color: #e53e3e;            /* Modern red for H1 */
            --h2-color: #3182ce;            /* Modern blue for H2 */
            --h3-color: #38a169;            /* Modern green for H3 */
            --shadow-soft: rgba(0, 0, 0, 0.05);
            --shadow-medium: rgba(0, 0, 0, 0.1);
            --shadow-large: rgba(0, 0, 0, 0.15);
            --font-primary: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            --font-secondary: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        body {
            background-color: var(--bg-primary);
            font-family: var(--font-primary);
            color: var(--text-primary);
            line-height: 1.7;
            font-weight: 400;
            letter-spacing: -0.01em;
        }

        .main-container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px 15px;
        }

        /* Typography improvements */
        h1, h2, h3, h4, h5, h6 {
            font-family: var(--font-secondary);
            font-weight: 600;
            letter-spacing: -0.02em;
            line-height: 1.3;
        }

        .display-4 {
            font-weight: 700;
            letter-spacing: -0.03em;
            color: var(--text-primary) !important;
        }

        .lead {
            font-size: 0.95rem;
            font-weight: 400;
            line-height: 1.5;
            color: var(--text-secondary) !important;
        }

        .upload-area {
            border: 2px dashed var(--border-color);
            border-radius: 12px;
            padding: 40px 30px;
            text-align: center;
            background: var(--bg-card);
            transition: all 0.3s ease;
            cursor: pointer;
            box-shadow: 0 1px 3px var(--shadow-soft);
            margin-bottom: 25px;
        }

        .upload-area:hover {
            border-color: var(--accent-primary);
            background-color: #f7fafc;
            box-shadow: 0 4px 20px var(--shadow-medium);
            transform: translateY(-2px);
        }

        .upload-area.dragover {
            border-color: var(--accent-primary);
            background-color: #ebf8ff;
            transform: scale(1.02);
        }

        .keyword-card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 12px 14px;
            margin-bottom: 8px;
            transition: all 0.3s ease;
            cursor: move;
            box-shadow: 0 1px 3px var(--shadow-soft);
            position: relative;
        }

        .keyword-card:hover {
            box-shadow: 0 8px 25px var(--shadow-medium);
            transform: translateY(-3px);
            border-color: var(--accent-primary);
        }

        .keyword-card.dragging {
            opacity: 0.7;
            transform: rotate(2deg);
        }

        /* Identifier section styling */
        .identifier-section {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            transition: all 0.3s ease;
            margin-bottom: 25px;
        }

        .identifier-section:hover {
            border-color: var(--accent-primary);
            box-shadow: 0 4px 16px var(--shadow-medium);
        }

        .identifier-section .card-header {
            background: var(--bg-primary);
            border-bottom: 1px solid var(--border-color);
            border-radius: 12px 12px 0 0;
            padding: 16px 20px 14px;
        }

        .identifier-section .card-body {
            padding: 20px;
        }

        /* H1 Keywords - Small and compact with very light red background */
        .tag-h1 {
            background: #fff5f5;
            border: 2px solid var(--text-primary);
            box-shadow: 0 2px 8px var(--shadow-soft);
            position: relative;
            padding: 12px 14px !important;
        }

        .tag-h1::before {
            content: "H1";
            position: absolute;
            top: -6px;
            left: 8px;
            background: var(--text-primary);
            color: var(--bg-card);
            padding: 1px 6px;
            border-radius: 4px;
            font-size: 0.6em;
            font-weight: 700;
            z-index: 1;
        }

        .tag-h1 .keyword-text {
            color: var(--text-primary) !important;
            font-weight: 600;
            font-size: 1.0em;
            letter-spacing: -0.01em;
        }

        /* H2 Keywords - Small and compact with very light blue background */
        .tag-h2 {
            background: #f0f8ff;
            border: 2px solid var(--text-secondary);
            box-shadow: 0 2px 6px var(--shadow-soft);
            padding: 12px 14px !important;
        }

        .tag-h2 .keyword-text {
            color: var(--text-primary) !important;
            font-weight: 600;
            font-size: 1.0em;
            letter-spacing: -0.01em;
        }

        /* H3 Keywords - Small and compact with green background */
        .tag-h3 {
            background: #ccd660;
            border: 2px solid var(--border-color);
            box-shadow: 0 1px 4px var(--shadow-soft);
            padding: 12px 14px !important;
        }

        .tag-h3 .keyword-text {
            color: var(--text-primary) !important;
            font-weight: 500;
            font-size: 0.95em;
        }

        /* Untagged keywords - Subtle styling */
        .tag-untagged {
            background: var(--bg-card);
            border: 2px dashed var(--text-muted);
            box-shadow: 0 1px 3px var(--shadow-soft);
            position: relative;
            padding: 12px 14px !important;
        }

        .tag-untagged .keyword-text {
            color: #000000 !important;
            font-weight: 500;
            font-size: 0.95em;
        }

        .volume-badge {
            font-size: 0.75em;
            padding: 6px 10px;
            background: rgba(255, 255, 255, 0.95) !important;
            color: var(--text-primary) !important;
            border: 1px solid var(--border-color);
            font-weight: 600;
            border-radius: 8px;
            letter-spacing: 0.01em;
        }

        .controls-panel {
            background: var(--bg-card);
            border-radius: 20px;
            padding: 40px;
            margin-bottom: 40px;
            box-shadow: 0 2px 8px var(--shadow-soft);
            border: 1px solid var(--border-color);
        }

        .keywords-container {
            background: var(--bg-card);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 2px 8px var(--shadow-soft);
            border: 1px solid var(--border-color);
        }

        .btn-tag {
            border: none;
            border-radius: 12px;
            padding: 10px 20px;
            margin: 4px;
            font-size: 0.9em;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px var(--shadow-soft);
            letter-spacing: 0.01em;
        }

        .btn-tag:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px var(--shadow-medium);
        }

        .btn-outline-danger {
            color: var(--text-primary);
            border-color: var(--text-primary);
            background: var(--bg-card);
            border-width: 2px;
            font-weight: 600;
        }

        .btn-outline-danger:hover {
            color: var(--bg-card);
            background: var(--text-primary);
            border-color: var(--text-primary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px var(--shadow-medium);
        }

        .btn-outline-success {
            color: var(--text-secondary);
            border-color: var(--text-secondary);
            background: var(--bg-card);
            border-width: 2px;
            font-weight: 600;
        }

        .btn-outline-success:hover {
            color: var(--bg-card);
            background: var(--text-secondary);
            border-color: var(--text-secondary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px var(--shadow-medium);
        }

        .btn-outline-info {
            color: var(--text-muted);
            border-color: var(--text-muted);
            background: var(--bg-card);
            border-width: 2px;
            font-weight: 600;
        }

        .btn-outline-info:hover {
            color: var(--bg-card);
            background: var(--text-muted);
            border-color: var(--text-muted);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px var(--shadow-medium);
        }

        .btn-remove {
            background: var(--danger-color);
            color: white;
            border: none;
            border-radius: 8px;
            width: 36px;
            height: 36px;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 6px rgba(220, 53, 69, 0.3);
        }

        .btn-remove:hover {
            background: #c82333;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(220, 53, 69, 0.5);
        }

        .drag-handle {
            cursor: move;
            color: var(--text-muted);
            margin-right: 12px;
            font-size: 16px;
        }

        .keyword-text {
            font-weight: 600;
            transition: all 0.3s ease;
            line-height: 1.4;
            font-size: 1.1em;
            letter-spacing: -0.01em;
        }

        .keyword-text:hover {
            text-decoration: none;
            color: var(--accent-primary);
        }

        .keyword-text.selected {
            color: var(--text-primary) !important;
            padding: 6px 10px !important;
            border-radius: 8px !important;
            box-shadow: 0 2px 8px var(--shadow-soft) !important;
            font-weight: 700 !important;
            position: relative !important;
        }

        /* Maintain hierarchy colors when selected - just add subtle highlight */
        .tag-h1 .keyword-text.selected {
            background: rgba(229, 62, 62, 0.15) !important; /* Light red background for H1 */
            border: 2px solid var(--h1-color) !important;
            color: var(--text-primary) !important;
            box-shadow: 0 2px 8px rgba(229, 62, 62, 0.2) !important;
            font-weight: 600 !important; /* Maintain H1 font weight */
            font-size: 1.0em !important; /* Maintain H1 font size */
            letter-spacing: -0.01em !important; /* Maintain H1 letter spacing */
        }

        .tag-h2 .keyword-text.selected {
            background: rgba(49, 130, 206, 0.15) !important; /* Light blue background for H2 */
            border: 2px solid var(--h2-color) !important;
            color: var(--text-primary) !important;
            box-shadow: 0 2px 8px rgba(49, 130, 206, 0.2) !important;
            font-weight: 600 !important; /* Maintain H2 font weight */
            font-size: 1.0em !important; /* Maintain H2 font size */
            letter-spacing: -0.01em !important; /* Maintain H2 letter spacing */
        }

        .tag-h3 .keyword-text.selected {
            background: rgba(56, 161, 105, 0.15) !important; /* Light green background for H3 */
            border: 2px solid var(--h3-color) !important;
            color: var(--text-primary) !important;
            box-shadow: 0 2px 8px rgba(56, 161, 105, 0.2) !important;
            font-weight: 500 !important; /* Maintain H3 font weight */
            font-size: 0.95em !important; /* Maintain H3 font size */
        }

        /* Ultra-high specificity override for debugging - REMOVED */
        /* This was causing all selected keywords to appear red regardless of hierarchy */

        /* Hover effects for selected keywords - maintain hierarchy colors */
        .tag-h1 .keyword-text.selected:hover {
            background: rgba(229, 62, 62, 0.25) !important;
            transform: scale(1.02) !important;
            box-shadow: 0 4px 12px rgba(229, 62, 62, 0.3) !important;
        }

        .tag-h2 .keyword-text.selected:hover {
            background: rgba(49, 130, 206, 0.25) !important;
            transform: scale(1.02) !important;
            box-shadow: 0 4px 12px rgba(49, 130, 206, 0.3) !important;
        }

        .tag-h3 .keyword-text.selected:hover {
            background: rgba(56, 161, 105, 0.25) !important;
            transform: scale(1.02) !important;
            box-shadow: 0 4px 12px rgba(56, 161, 105, 0.3) !important;
        }

        /* Remove the "SELECTED" badges - just use subtle highlighting */
        .keyword-text.selected::before {
            content: none;
        }

        /* No specific badges for selected keywords */
        .tag-h1 .keyword-text.selected::before {
            content: none;
        }

        .tag-h2 .keyword-text.selected::before {
            content: none;
        }

        .tag-h3 .keyword-text.selected::before {
            content: none;
        }

        /* General hover for non-H1/H2/H3 selected keywords */
        .keyword-text.selected:hover {
            background: rgba(59, 130, 246, 0.15) !important;
            color: var(--text-primary) !important;
            text-decoration: none !important;
            transform: scale(1.02) !important;
        }

        /* Ensure hierarchy colors are maintained even when multiple keywords are selected */
        .tag-h1 .keyword-text.selected,
        .tag-h1 .keyword-text.selected:hover {
            color: var(--text-primary) !important;
            font-weight: 800 !important;
            font-size: 1.8em !important;
            letter-spacing: -0.02em !important;
        }

        .tag-h2 .keyword-text.selected,
        .tag-h2 .keyword-text.selected:hover {
            color: var(--text-primary) !important;
            font-weight: 700 !important;
            font-size: 1.4em !important;
            letter-spacing: -0.01em !important;
        }

        .tag-h3 .keyword-text.selected,
        .tag-h3 .keyword-text.selected:hover {
            color: var(--text-primary) !important;
            font-weight: 600 !important;
            font-size: 1.1em !important;
        }

        .keyword-text.editing {
            background: var(--bg-secondary);
            border: 2px solid var(--accent-cool);
            border-radius: 8px;
            padding: 6px 12px;
            outline: none;
            box-shadow: 0 0 0 3px rgba(13, 110, 253, 0.2);
            color: var(--text-primary);
        }

        .edit-input {
            background: var(--bg-secondary);
            border: 2px solid var(--accent-cool);
            border-radius: 8px;
            padding: 6px 12px;
            outline: none;
            font-size: inherit;
            font-weight: inherit;
            width: 100%;
            box-shadow: 0 0 0 3px rgba(13, 110, 253, 0.2);
            color: var(--text-primary);
        }

        .edit-buttons {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .edit-btn {
            padding: 4px 12px;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .save-btn {
            background: var(--success-color);
            color: white;
        }

        .save-btn:hover {
            background: #157347;
        }

        .cancel-btn {
            background: var(--danger-color);
            color: white;
        }

        .cancel-btn:hover {
            background: #c82333;
        }

        .intent-badge {
            font-size: 0.8em;
            padding: 6px 10px;
            border-radius: 10px;
            background: var(--bg-primary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
            font-weight: 500;
            letter-spacing: 0.01em;
        }

        .keyword-checkbox {
            border: 2px solid var(--text-secondary) !important;
            border-radius: 4px !important;
            width: 20px !important;
            height: 20px !important;
        }

        .keyword-checkbox:checked {
            background-color: var(--accent-cool) !important;
            border-color: var(--accent-cool) !important;
        }

        .form-check {
            margin-right: 18px !important;
        }

        .h3-container {
            background: var(--bg-primary);
            border-radius: 12px;
            margin-top: 12px;
            margin-bottom: 12px;
            border: 1px solid var(--border-color);
            padding: 16px;
        }

        .copy-icon {
            transition: all 0.2s ease;
            opacity: 0.7;
        }

        .copy-icon:hover {
            opacity: 1;
            color: var(--accent-primary) !important;
            transform: scale(1.1);
        }

        .copy-icon.copied {
            color: var(--accent-secondary) !important;
            animation: copySuccess 0.5s ease;
        }

        @keyframes copySuccess {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        .h3-container .keyword-card {
            margin-bottom: 10px;
            border-left: 4px solid var(--accent-cool);
        }
        
        /* Ensure H3 keywords maintain their green background even when nested */
        .h3-container .keyword-card.tag-h3 {
            background: #ccd660;
        }

        .h3-container .keyword-card:last-child {
            margin-bottom: 0;
        }

        .search-results-list {
            max-height: 350px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 12px;
            background: var(--bg-primary);
        }

        .search-result-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 18px;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-card);
            transition: all 0.3s ease;
        }

        .search-result-item:hover {
            background: #f8f9ff;
        }

        .search-result-item:last-child {
            border-bottom: none;
        }

        .search-result-info {
            flex-grow: 1;
        }

        .search-result-keyword {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
            font-size: 1.1em;
        }

        .search-result-details {
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        .search-result-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .search-result-tag {
            font-size: 0.8em;
            padding: 4px 8px;
            border-radius: 12px;
            font-weight: 600;
        }

        .search-result-tag.h1 {
            background: var(--text-primary);
            color: var(--bg-card);
            border: 1px solid var(--text-primary);
            font-weight: 700;
        }

        .search-result-tag.h2 {
            background: var(--text-secondary);
            color: var(--bg-card);
            border: 1px solid var(--text-secondary);
            font-weight: 600;
        }

        .search-result-tag.h3 {
            background: var(--text-muted);
            color: var(--bg-card);
            border: 1px solid var(--text-muted);
            font-weight: 500;
        }

        .search-result-tag.untagged {
            background: var(--text-muted);
            color: var(--bg-card);
            border: 1px dashed var(--text-muted);
            font-weight: 400;
        }

        .keyword-card.tag-h2.drag-over {
            border: 2px dashed var(--h2-color) !important;
            background-color: rgba(13, 110, 253, 0.1) !important;
            transform: scale(1.02) !important;
            transition: all 0.3s ease;
            box-shadow: 0 6px 16px var(--shadow-medium) !important;
        }
        
        /* H2 section reordering styles */
        .keyword-card.tag-h2 {
            cursor: grab;
            transition: all 0.3s ease;
        }
        
        .keyword-card.tag-h2:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px var(--shadow-medium);
        }
        
        .keyword-card.tag-h2:active {
            cursor: grabbing;
            transform: scale(0.98);
        }
        
        .keyword-card.tag-h2.dragging {
            opacity: 0.8;
            transform: rotate(2deg) scale(1.05);
            box-shadow: 0 8px 16px var(--shadow-medium);
            z-index: 1000;
        }
        
        /* Enhanced drag handle for H2 sections */
        .keyword-card.tag-h2 .drag-handle {
            color: var(--h2-color);
            font-size: 18px;
            margin-right: 15px;
            cursor: grab;
            transition: all 0.3s ease;
        }
        
        .keyword-card.tag-h2 .drag-handle:hover {
            color: var(--accent-primary);
            transform: scale(1.1);
        }
        
        .keyword-card.tag-h2:active .drag-handle {
            cursor: grabbing;
        }

        /* Reorder buttons styling */
        .reorder-buttons {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .reorder-btn {
            padding: 4px 6px;
            font-size: 10px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: var(--bg-card);
            color: var(--text-muted);
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .reorder-btn:hover {
            background: var(--accent-primary);
            color: white;
            border-color: var(--accent-primary);
            transform: scale(1.1);
        }

        .reorder-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .reorder-btn:disabled:hover {
            background: var(--bg-card);
            color: var(--text-muted);
            border-color: var(--border-color);
            transform: none;
        }

        .keyword-card.tag-h3 {
            cursor: grab;
            transition: all 0.3s ease;
        }

        .keyword-card.tag-h3:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px var(--shadow-medium);
        }

        .keyword-card.tag-h3:active {
            cursor: grabbing;
            transform: scale(0.98);
        }

        .keyword-card.tag-h3.dragging {
            opacity: 0.8;
            transform: rotate(2deg) scale(1.05);
            box-shadow: 0 8px 16px var(--shadow-medium);
        }

        .keyword-card.tag-h2 {
            position: relative;
        }

        .keyword-card.tag-h2::after {
            content: "Drop H3 here";
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--h2-color);
            color: #ffffff;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 0.8em;
            font-weight: 700;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            box-shadow: 0 4px 12px var(--shadow-medium);
            border: 2px solid #000000;
        }

        .keyword-card.tag-h2.drag-over::after {
            opacity: 1;
        }

        /* Additional neutral theme improvements */
        .display-4 {
            color: var(--text-primary) !important;
            font-weight: 700;
        }

        .text-primary {
            color: var(--accent-cool) !important;
        }

        .text-muted {
            color: var(--text-muted) !important;
        }

        .text-dark {
            color: var(--text-primary) !important;
        }

        .form-control {
            border-color: var(--border-color);
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            border-radius: 12px;
            padding: 12px 16px;
            font-size: 1rem;
            transition: all 0.3s ease;
            border-width: 1px;
        }

        .form-control:focus {
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(49, 130, 206, 0.1);
            background-color: var(--bg-secondary);
        }

        .btn-primary {
            background-color: var(--accent-primary);
            border-color: var(--accent-primary);
            color: #ffffff;
            font-weight: 600;
            border-radius: 12px;
            padding: 12px 24px;
            transition: all 0.3s ease;
            letter-spacing: 0.01em;
        }

        .btn-primary:hover {
            background-color: #2c5282;
            border-color: #2c5282;
            color: #ffffff;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(49, 130, 206, 0.3);
        }

        .btn-success {
            background-color: var(--success-color);
            border-color: var(--success-color);
            color: #ffffff;
            font-weight: 600;
        }

        .btn-success:hover {
            background-color: #157347;
            border-color: #157347;
            color: #ffffff;
        }

        .btn-warning {
            background-color: var(--warning-color);
            border-color: var(--warning-color);
            color: #ffffff;
            font-weight: 600;
        }

        .btn-warning:hover {
            background-color: #e55a2b;
            border-color: #e55a2b;
            color: #ffffff;
        }

        .btn-danger {
            background-color: var(--danger-color);
            border-color: var(--danger-color);
            color: #ffffff;
            font-weight: 600;
        }

        .btn-danger:hover {
            background-color: #c82333;
            border-color: #c82333;
            color: #ffffff;
        }

        .btn-secondary {
            background-color: var(--text-secondary);
            border-color: var(--text-secondary);
            color: #ffffff;
            font-weight: 600;
        }

        .btn-secondary:hover {
            background-color: #5a6268;
            border-color: #5a6268;
            color: #ffffff;
        }

        .badge {
            font-size: 0.85em;
            padding: 6px 10px;
        }

        .badge.bg-primary {
            background-color: var(--accent-cool) !important;
            color: #ffffff !important;
        }

        .badge.bg-secondary {
            background-color: var(--text-secondary) !important;
            color: #ffffff !important;
        }

        /* Scrollbar styling for neutral theme */
        ::-webkit-scrollbar {
            width: 12px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-primary);
            border-radius: 6px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--text-muted);
            border-radius: 6px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }

        /* Focus indicators for accessibility */
        .btn:focus,
        .form-control:focus,
        .keyword-text:focus {
            outline: 2px solid var(--accent-cool);
            outline-offset: 2px;
        }

        /* Reduce motion for users who prefer it */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="text-center mb-4">
            <h1 class="display-4 text-primary">
                <i class="fas fa-key"></i> Keyword Hierarchy Dashboard
            </h1>
            <p class="lead text-muted">Upload your SEMrush CSV and organize keywords into H1, H2, H3 structure</p>
            <button class="btn btn-secondary" onclick="testConnection()">Test Connection</button>
        </div>

        <!-- Upload Section -->
        <div class="upload-area" id="uploadArea" onclick="document.getElementById('fileInput').click()">
            <i class="fas fa-cloud-upload-alt fa-3x text-muted mb-3"></i>
            <h4>Upload SEMrush CSV File</h4>
            <p class="text-muted">Click to browse or drag and drop your CSV file here</p>
            <input type="file" id="fileInput" accept=".csv" style="display: none;">
        </div>

        <!-- Identifier Section -->
        <div class="card mt-4 identifier-section">
            <div class="card-header">
                <h5 class="mb-0"><i class="fas fa-tags"></i> Project Identifier</h5>
                <small class="text-muted">These fields will be included in the JSON structure but not sent to AI</small>
            </div>
            <div class="card-body">
                <div class="row">
                                   <div class="col-md-6">
                   <div class="form-group">
                       <label for="projectHandle" class="form-label">Handle</label>
                       <input type="text" class="form-control" id="projectHandle" placeholder="Enter project handle (e.g., acrylic-nails-project)" required>
                   </div>
               </div>
               <div class="col-md-6">
                   <div class="form-group">
                       <label for="projectTags" class="form-label">Tags</label>
                       <input type="text" class="form-control" id="projectTags" placeholder="Enter tags separated by commas (e.g., nails, beauty, acrylic)" required>
                   </div>
               </div>
                </div>
            </div>
        </div>

        <!-- Hero Section -->
        <div class="card mt-4 hero-section">
            <div class="card-header">
                <h5 class="mb-0"><i class="fas fa-star"></i> Hero Section</h5>
                <small class="text-muted">Enter these fields manually - they will be included in the final JSON</small>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-4">
                        <div class="form-group">
                            <label for="heroTagline" class="form-label">Tagline</label>
                            <input type="text" class="form-control" id="heroTagline" placeholder="Enter compelling headline" required>
                            <small class="text-muted">Compelling headline for the hero section</small>
                        </div>
                    </div>
                    <div class="col-md-4">
                        <div class="form-group">
                            <label for="heroCTA" class="form-label">CTA Text</label>
                            <input type="text" class="form-control" id="heroCTA" placeholder="e.g., 'Book Now', 'Learn More'" required>
                            <small class="text-muted">Button text for call-to-action</small>
                        </div>
                    </div>
                    <div class="col-md-4">
                        <div class="form-group">
                            <label for="heroCTALink" class="form-label">CTA Link</label>
                            <input type="text" class="form-control" id="heroCTALink" placeholder="e.g., 'book-appointment'" required>
                            <small class="text-muted">URL-friendly name for the link</small>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Controls Panel -->
        <div class="controls-panel" id="controlsPanel" style="display: none;">
            <div class="row align-items-center justify-content-between">
                <div class="col-md-2">
                    <div class="input-group">
                        <input type="number" class="form-control" id="volumeFilter" value="400" min="0" placeholder="Volume">
                        <button class="btn btn-dark" onclick="filterKeywords()">
                            <i class="fas fa-filter"></i> Filter
                        </button>
                    </div>
                </div>
                <div class="col-md-3">
                    <div class="d-flex gap-3">
                        <button class="btn btn-dark" onclick="downloadStructuredJSON()">
                            <i class="fas fa-download"></i> Download JSON
                        </button>
                        <button class="btn btn-primary" onclick="generateContent()" id="generateBtn">
                            <i class="fas fa-magic"></i> Generate Content
                        </button>
                    </div>
                </div>
                <div class="col-md-4 ms-4">
                    <div class="d-flex gap-3 align-items-center">
                        <div class="form-check me-4">
                            <input class="form-check-input" type="checkbox" id="selectAllCheckbox" onchange="toggleSelectAll()">
                            <label class="form-check-label" for="selectAllCheckbox">
                                <strong>Select All</strong>
                            </label>
                        </div>
                        <button class="btn btn-dark" onclick="addNewH2()">
                            <i class="fas fa-plus"></i> Add H2
                        </button>
                        <button class="btn btn-danger" onclick="removeSelectedH2s()" id="removeH2Btn" style="display: none;">
                            <i class="fas fa-trash"></i> Remove Selected
                        </button>
                    </div>
                </div>
                <div class="col-md-2">
                    <div class="d-flex justify-content-end align-items-center">
                        <span class="badge bg-dark" id="keywordCount">0 keywords</span>
                    </div>
                </div>
            </div>
        </div>



        <!-- Keywords Container -->
        <div class="keywords-container" id="keywordsContainer" style="display: none;">
            <h4 class="mb-3">
                <i class="fas fa-list"></i> Keywords
                <small class="text-muted">(Drag to reorder, click tags to assign)</small>
            </h4>
            
            <!-- Search Section -->
            <div class="search-section mb-4">
                <div class="input-group">
                    <span class="input-group-text">
                        <i class="fas fa-search"></i>
                    </span>
                    <input type="text" class="form-control" id="keywordSearch" placeholder="Search keywords..." oninput="searchKeywords()">
                    <button class="btn btn-outline-secondary" type="button" onclick="clearSearch()">
                        <i class="fas fa-times"></i> Clear
                    </button>
                </div>
                <div id="searchResults" class="mt-3" style="display: none;">
                    <h6 class="text-muted mb-2">
                        <i class="fas fa-search"></i> Search Results
                        <span id="searchCount" class="badge bg-primary ms-2">0</span>
                    </h6>
                    <div id="searchResultsList" class="search-results-list"></div>
                </div>
            </div>
            
            <div id="keywordsList"></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        let currentData = [];
        let filteredData = [];

        // File upload handling
        const fileInput = document.getElementById('fileInput');
        console.log('File input element:', fileInput); // Debug log
        
        fileInput.addEventListener('change', (event) => {
            console.log('File input change event triggered'); // Debug log
            handleFileUpload(event);
        });
        
        // Drag and drop
        const uploadArea = document.getElementById('uploadArea');
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        function handleFileUpload(event) {
            console.log('handleFileUpload called'); // Debug log
            console.log('Event target files:', event.target.files); // Debug log
            const file = event.target.files[0];
            if (file) {
                console.log('File selected:', file.name, file.type); // Debug log
                handleFile(file);
            } else {
                console.log('No file selected'); // Debug log
            }
        }

        function handleFile(file) {
            console.log('handleFile called with:', file.name); // Debug log
            const formData = new FormData();
            formData.append('file', file);

            console.log('Sending request to /upload'); // Debug log
            fetch('/upload', {
                method: 'POST',
                body: formData
            })
            .then(response => {
                console.log('Response status:', response.status); // Debug log
                return response.json();
            })
            .then(data => {
                console.log('Response data:', data); // Debug log
                if (data.success) {
                    currentData = data.data;
                    filteredData = currentData.filter(kw => kw.volume >= 400);
                    showControls();
                    renderKeywords();
                    showNotification(data.message, 'success');
                } else {
                    showNotification(data.error, 'error');
                }
            })
            .catch(error => {
                console.error('Error:', error); // Debug log
                showNotification('Error uploading file: ' + error.message, 'error');
            });
        }

        function filterKeywords() {
            const minVolume = parseInt(document.getElementById('volumeFilter').value);
            
            fetch('/filter', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ min_volume: minVolume })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    filteredData = data.data;
                    renderKeywords();
                    showNotification(`Filtered to ${data.count} keywords. Working with filtered data only.`, 'success');
                } else {
                    showNotification(data.error, 'error');
                }
            })
            .catch(error => {
                showNotification('Error filtering keywords: ' + error.message, 'error');
            });
        }

        function assignTag(keywordId, tag) {
            fetch('/update_tags', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    updates: [{ id: keywordId, tag: tag }]
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Update local data
                    const keyword = filteredData.find(kw => kw.id === keywordId);
                    if (keyword) {
                        keyword.tag = tag;
                        
                        // If assigning H3 tag, automatically assign parent H2
                        if (tag === 'H3') {
                            assignParentH2(keywordId);
                        }
                    }
                    renderKeywords();
                    
                    // Preserve checkbox selections after rendering
                    setTimeout(() => {
                        // Restore checkbox selections after re-rendering
                        document.querySelectorAll('.keyword-checkbox').forEach(checkbox => {
                            if (checkbox.checked) {
                                const keywordCard = checkbox.closest('.keyword-card');
                                const keywordText = keywordCard.querySelector('.keyword-text');
                                if (keywordText) {
                                    keywordText.classList.add('selected');
                                }
                            }
                        });
                    }, 100);
                    
                    showNotification('Tag updated successfully', 'success');
                } else {
                    showNotification(data.error, 'error');
                }
            })
            .catch(error => {
                showNotification('Error updating tag: ' + error.message, 'error');
            });
        }
        
        function assignParentH2(h3KeywordId) {
            // Find the H2 keyword that comes before this H3 keyword
            const h3Keyword = filteredData.find(kw => kw.id === h3KeywordId);
            if (!h3Keyword) return;
            
            const h3Order = h3Keyword.order;
            const h2Keywords = filteredData.filter(kw => kw.tag === 'H2').sort((a, b) => b.order - a.order); // Sort descending
            
            // Find the closest H2 that comes before this H3
            for (const h2Kw of h2Keywords) {
                if (h2Kw.order < h3Order) {
                    // Assign this H2 as parent
                    h3Keyword.parent_id = h2Kw.id;
                    break;
                }
            }
        }

        function removeKeyword(keywordId) {
            // Remove without confirmation
            fetch('/remove_keyword', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ id: keywordId })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Remove from filtered data (this is what we're working with)
                    filteredData = filteredData.filter(kw => kw.id !== keywordId);
                    
                    // Update order
                    for (let i = 0; i < filteredData.length; i++) {
                        filteredData[i].order = i;
                    }
                    
                    // Update backend with the new data and wait for completion
                    updateBackendData().then(() => {
                        renderKeywords();
                        showNotification('Keyword removed successfully', 'success');
                    }).catch(error => {
                        console.error('Error updating backend data:', error);
                        showNotification('Error updating data. Please try again.', 'error');
                    });
                } else {
                    showNotification(data.error, 'error');
                }
            })
            .catch(error => {
                showNotification('Error removing keyword: ' + error.message, 'error');
            });
        }


        function downloadStructuredJSON() {
            console.log('Downloading data - filteredData length:', filteredData.length);
            console.log('Downloading data - filteredData:', filteredData);
            
            // Get identifier data from form inputs
            const handle = document.getElementById('projectHandle').value.trim();
            const tags = document.getElementById('projectTags').value.trim();
            
            // Create the complete data structure with identifier
            const completeData = {
                identifier: {
                    handle: handle || 'default-handle',
                    tags: tags || 'default-tags'
                },
                data: filteredData
            };
            
            // Use completeData for download (includes identifier + filtered keywords)
            const dataToDownload = completeData;
            
            // First, ensure backend is synced with the data we want to download
            updateBackendData().then(() => {
                // Then download with a small delay to ensure backend has processed the update
                setTimeout(() => {
                    fetch('/download', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ data: dataToDownload })
                    })
                    .then(response => {
                        if (response.ok) {
                            return response.blob();
                        }
                        throw new Error('Download failed');
                    })
                    .then(blob => {
                        const url = window.URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'keyword_hierarchy.json';
                        document.body.appendChild(a);
                        a.click();
                        window.URL.revokeObjectURL(url);
                        document.body.removeChild(a);
                        showNotification('Structured JSON file downloaded successfully', 'success');
                    })
                    .catch(error => {
                        showNotification('Error downloading file: ' + error.message, 'error');
                    });
                }, 200); // 200ms delay after backend sync
            }).catch(error => {
                console.error('Error syncing with backend before download:', error);
                showNotification('Error syncing data before download. Please try again.', 'error');
            });
        }



        function renderKeywords() {
            const container = document.getElementById('keywordsList');
            const keywordCount = document.getElementById('keywordCount');
            
            keywordCount.textContent = `${filteredData.length} keywords`;
            
            container.innerHTML = '';
            
            // Group keywords by tag
            const h1Keywords = filteredData.filter(kw => kw.tag === 'H1');
            const h2Keywords = filteredData.filter(kw => kw.tag === 'H2');
            const h3Keywords = filteredData.filter(kw => kw.tag === 'H3');
            const untaggedKeywords = filteredData.filter(kw => !kw.tag);
            
            // Render H1 keywords
            if (h1Keywords.length > 0) {
                const h1Section = document.createElement('div');
                h1Section.className = 'mb-4';
                h1Section.innerHTML = '<h5 class="text-dark mb-3"><i class="fas fa-heading"></i> H1 Keywords</h5>';
                h1Keywords.forEach(keyword => {
                    h1Section.appendChild(createKeywordCard(keyword));
                });
                container.appendChild(h1Section);
            }
            
            // Render H2 keywords with their related H3 keywords
            if (h2Keywords.length > 0) {
                const h2Section = document.createElement('div');
                h2Section.className = 'mb-4';
                h2Section.innerHTML = '<h5 class="text-dark mb-3"><i class="fas fa-heading"></i> H2 Keywords</h5>';
                
                // Sort keywords by order
                h2Keywords.sort((a, b) => a.order - b.order);
                h3Keywords.sort((a, b) => a.order - b.order);
                
                h2Keywords.forEach(h2Keyword => {
                    // Create H2 card
                    const h2Card = createKeywordCard(h2Keyword, true);
                    
                    // Find H3 keywords that belong to this H2 using parent_id
                    const relatedH3Keywords = h3Keywords.filter(h3Kw => 
                        h3Kw.parent_id === h2Keyword.id
                    );
                    
                    // If there are related H3 keywords, create a container for them
                    if (relatedH3Keywords.length > 0) {
                        const h3Container = document.createElement('div');
                        h3Container.className = 'h3-container ms-4 mt-2';
                        h3Container.style.borderLeft = '3px solid #45b7d1';
                        h3Container.style.paddingLeft = '15px';
                        
                        // Add a small header to show this is H3 keywords
                        const h3Header = document.createElement('div');
                        h3Header.className = 'text-dark mb-2';
                        h3Header.style.fontSize = '0.9em';
                        h3Header.style.fontWeight = '500';
                        h3Header.innerHTML = `<i class="fas fa-level-down-alt"></i> Related H3 Keywords (${relatedH3Keywords.length})`;
                        h3Container.appendChild(h3Header);
                        
                        relatedH3Keywords.forEach(h3Keyword => {
                            const h3Card = createKeywordCard(h3Keyword, false);
                            h3Container.appendChild(h3Card);
                        });
                        
                        // Append H3 container to H2 card
                        h2Card.appendChild(h3Container);
                    }
                    
                    h2Section.appendChild(h2Card);
                });
                
                container.appendChild(h2Section);
            }
            
            // Render remaining H3 keywords (those that don't belong to any H2)
            const remainingH3Keywords = h3Keywords.filter(h3Kw => !h3Kw.parent_id);
            
            if (remainingH3Keywords.length > 0) {
                const h3Section = document.createElement('div');
                h3Section.className = 'mb-4';
                h3Section.innerHTML = '<h5 class="text-dark mb-3"><i class="fas fa-heading"></i> H3 Keywords (Unassigned)</h5>';
                remainingH3Keywords.forEach(keyword => {
                    h3Section.appendChild(createKeywordCard(keyword));
                });
                container.appendChild(h3Section);
            }
            
            // Render untagged keywords
            if (untaggedKeywords.length > 0) {
                const untaggedSection = document.createElement('div');
                untaggedSection.className = 'mb-4';
                untaggedSection.innerHTML = '<h5 class="text-dark mb-3"><i class="fas fa-tags"></i> Untagged Keywords</h5>';
                untaggedKeywords.forEach(keyword => {
                    untaggedSection.appendChild(createKeywordCard(keyword));
                });
                container.appendChild(untaggedSection);
            }
            
            setupDragAndDrop();
            updateRemoveButton();
        }
        
        function createKeywordCard(keyword, isH2 = false) {
            const card = document.createElement('div');
            card.className = `keyword-card ${keyword.tag ? 'tag-' + keyword.tag.toLowerCase() : 'tag-untagged'}`;
            card.draggable = true;
            card.dataset.id = keyword.id;
            
            const checkbox = `
                <div class="form-check me-3">
                    <input class="form-check-input keyword-checkbox" type="checkbox" value="${keyword.id}" 
                           onchange="handleCheckboxChange(this)" style="width: 18px; height: 18px; cursor: pointer;">
                    <label class="form-check-label" for="checkbox-${keyword.id}" style="cursor: pointer;"></label>
                </div>
            `;
            
            const copyIcon = keyword.tag === 'H1' ? `<i class="fas fa-copy copy-icon" onclick="copyKeyword('${keyword.keyword}')" title="Copy keyword" style="cursor: pointer; margin-right: 8px; color: var(--text-muted);"></i>` : '';
            const keywordText = `<div class="keyword-text" onclick="editKeyword(${keyword.id})" style="cursor: pointer;">${copyIcon}${keyword.keyword}</div>`;
            
            // Add reorder buttons for H2 sections
            let reorderButtons = '';
            if (keyword.tag === 'H2') {
                reorderButtons = `
                    <div class="reorder-buttons me-2">
                        <button class="btn btn-sm btn-outline-secondary reorder-btn" onclick="moveH2Up(${keyword.id})" title="Move H2 up">
                            <i class="fas fa-chevron-up"></i>
                        </button>
                        <button class="btn btn-sm btn-outline-secondary reorder-btn" onclick="moveH2Down(${keyword.id})" title="Move H2 down">
                            <i class="fas fa-chevron-down"></i>
                        </button>
                    </div>
                `;
            }
            
            // Add reorder buttons for H3 sections within H2 containers
            if (keyword.tag === 'H3' && isH2 === false) {
                reorderButtons = `
                    <div class="reorder-buttons me-2">
                        <button class="btn btn-sm btn-outline-secondary reorder-btn" onclick="moveH3Up(${keyword.id})" title="Move H3 up">
                            <i class="fas fa-chevron-up"></i>
                        </button>
                        <button class="btn btn-sm btn-outline-secondary reorder-btn" onclick="moveH3Down(${keyword.id})" title="Move H3 down">
                            <i class="fas fa-chevron-down"></i>
                        </button>
                    </div>
                `;
            }
            
            card.innerHTML = `
                <div class="d-flex align-items-center justify-content-between">
                    <div class="d-flex align-items-center flex-grow-1">
                        ${checkbox}
                        <i class="fas fa-grip-vertical drag-handle me-2"></i>
                        ${reorderButtons}
                        <div class="flex-grow-1">
                            ${keywordText}
                            <div class="mt-1">
                                <span class="badge bg-secondary volume-badge">
                                    <i class="fas fa-chart-line"></i> ${keyword.volume.toLocaleString()}
                                </span>
                                ${keyword.intent ? `<span class="intent-badge ms-2">${keyword.intent}</span>` : ''}
                            </div>
                        </div>
                    </div>
                    <div class="d-flex align-items-center gap-2">
                        <div class="btn-group" role="group">
                            <button type="button" class="btn-tag ${keyword.tag === 'H1' ? 'tag-h1' : 'btn-outline-danger'}" 
                                    onclick="assignTag(${keyword.id}, 'H1')">H1</button>
                            <button type="button" class="btn-tag ${keyword.tag === 'H2' ? 'tag-h2' : 'btn-outline-success'}" 
                                    onclick="assignTag(${keyword.id}, 'H2')">H2</button>
                            <button type="button" class="btn-tag ${keyword.tag === 'H3' ? 'tag-h3' : 'btn-outline-info'}" 
                                    onclick="assignTag(${keyword.id}, 'H3')">H3</button>
                        </div>
                        <button class="btn-remove" onclick="removeKeyword(${keyword.id})">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                </div>
            `;
            
            return card;
        }

        function setupDragAndDrop() {
            const cards = document.querySelectorAll('.keyword-card');
            
            cards.forEach(card => {
                card.addEventListener('dragstart', handleDragStart);
                card.addEventListener('dragend', handleDragEnd);
                card.addEventListener('dragover', handleDragOver);
                card.addEventListener('drop', handleDrop);
            });
            
            // Add drop zones for H2 keywords to accept H3 drops
            const h2Cards = document.querySelectorAll('.keyword-card.tag-h2');
            h2Cards.forEach(h2Card => {
                h2Card.addEventListener('dragover', handleH2DragOver);
                h2Card.addEventListener('drop', handleH2Drop);
            });
            
            // Add H2 section reordering functionality
            setupH2SectionReordering();
        }
        
        function setupH2SectionReordering() {
            const h2Section = document.querySelector('.mb-4:has(.tag-h2)');
            if (!h2Section) return;
            
            const h2Cards = h2Section.querySelectorAll('.keyword-card.tag-h2');
            
            h2Cards.forEach(h2Card => {
                // Make H2 cards draggable for reordering
                h2Card.draggable = true;
                h2Card.addEventListener('dragstart', handleH2SectionDragStart);
                h2Card.addEventListener('dragend', handleH2SectionDragEnd);
                h2Card.addEventListener('dragover', handleH2SectionDragOver);
                h2Card.addEventListener('drop', handleH2SectionDrop);
            });
        }
        
        function handleH2SectionDragStart(e) {
            e.stopPropagation(); // Prevent triggering the regular keyword drag
            e.target.classList.add('dragging');
            e.dataTransfer.setData('text/plain', e.target.dataset.id);
            e.dataTransfer.setData('application/h2-section', 'true'); // Mark as H2 section drag
            
            // Add visual feedback
            e.target.style.opacity = '0.7';
            e.target.style.transform = 'rotate(2deg) scale(1.05)';
        }
        
        function handleH2SectionDragEnd(e) {
            e.target.classList.remove('dragging');
            e.target.style.opacity = '';
            e.target.style.transform = '';
            
            // Remove any drop indicators
            document.querySelectorAll('.keyword-card.tag-h2').forEach(card => {
                card.classList.remove('drag-over');
            });
        }
        
        function handleH2SectionDragOver(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const draggedId = parseInt(e.dataTransfer.getData('text/plain'));
            const targetId = parseInt(e.target.closest('.keyword-card').dataset.id);
            
            // Only allow H2 to H2 reordering
            if (draggedId !== targetId) {
                const h2Card = e.target.closest('.keyword-card.tag-h2');
                if (h2Card) {
                    h2Card.classList.add('drag-over');
                }
            }
        }
        
        function handleH2SectionDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const draggedId = parseInt(e.dataTransfer.getData('text/plain'));
            const targetId = parseInt(e.target.closest('.keyword-card').dataset.id);
            
            // Reset styling
            document.querySelectorAll('.keyword-card.tag-h2').forEach(card => {
                card.classList.remove('drag-over');
            });
            
            if (draggedId !== targetId) {
                reorderH2Sections(draggedId, targetId);
            }
        }
        
        function reorderH2Sections(draggedId, targetId) {
            // Get all H2 keywords
            const h2Keywords = filteredData.filter(kw => kw.tag === 'H2');
            
            // Find the indices of the dragged and target H2 keywords
            const draggedIndex = h2Keywords.findIndex(kw => kw.id === draggedId);
            const targetIndex = h2Keywords.findIndex(kw => kw.id === targetId);
            
            if (draggedIndex !== -1 && targetIndex !== -1) {
                // Reorder H2 keywords
                const [draggedH2] = h2Keywords.splice(draggedIndex, 1);
                h2Keywords.splice(targetIndex, 0, draggedH2);
                
                // Update the order in the main filteredData array
                let currentOrder = 0;
                filteredData.forEach(kw => {
                    if (kw.tag === 'H2') {
                        // Find the H2 keyword in our reordered list
                        const h2Kw = h2Keywords.find(h2 => h2.id === kw.id);
                        if (h2Kw) {
                            kw.order = currentOrder++;
                        }
                    }
                });
                
                // Update backend
                updateBackendData().then(() => {
                    renderKeywords();
                    showNotification('H2 sections reordered successfully', 'success');
                }).catch(error => {
                    console.error('Error updating backend data:', error);
                    showNotification('Error reordering H2 sections. Please try again.', 'error');
                });
            }
        }

        // H2 reordering functions
        function moveH2Up(keywordId) {
            const h2Keywords = filteredData.filter(kw => kw.tag === 'H2').sort((a, b) => a.order - b.order);
            const currentIndex = h2Keywords.findIndex(kw => kw.id === keywordId);
            
            if (currentIndex > 0) {
                // Swap with the previous H2
                const currentH2 = h2Keywords[currentIndex];
                const previousH2 = h2Keywords[currentIndex - 1];
                
                // Update orders
                currentH2.order = previousH2.order;
                previousH2.order = currentH2.order + 1;
                
                // Update backend
                updateBackendData().then(() => {
                    renderKeywords();
                    showNotification('H2 section moved up successfully', 'success');
                }).catch(error => {
                    console.error('Error updating backend data:', error);
                    showNotification('Error moving H2 section. Please try again.', 'error');
                });
            }
        }

        function moveH2Down(keywordId) {
            const h2Keywords = filteredData.filter(kw => kw.tag === 'H2').sort((a, b) => a.order - b.order);
            const currentIndex = h2Keywords.findIndex(kw => kw.id === keywordId);
            
            if (currentIndex < h2Keywords.length - 1) {
                // Swap with the next H2
                const currentH2 = h2Keywords[currentIndex];
                const nextH2 = h2Keywords[currentIndex + 1];
                
                // Update orders
                currentH2.order = nextH2.order;
                nextH2.order = currentH2.order - 1;
                
                // Update backend
                updateBackendData().then(() => {
                    renderKeywords();
                    showNotification('H2 section moved down successfully', 'success');
                }).catch(error => {
                    console.error('Error updating backend data:', error);
                    showNotification('Error moving H2 section. Please try again.', 'error');
                });
            }
        }

        // H3 reordering functions within their parent H2
        function moveH3Up(keywordId) {
            const h3Keyword = filteredData.find(kw => kw.id === keywordId);
            if (!h3Keyword || h3Keyword.tag !== 'H3' || !h3Keyword.parent_id) return;
            
            // Get all H3 keywords that belong to the same parent H2
            const siblingH3s = filteredData.filter(kw => 
                kw.tag === 'H3' && kw.parent_id === h3Keyword.parent_id
            ).sort((a, b) => a.order - b.order);
            
            const currentIndex = siblingH3s.findIndex(kw => kw.id === keywordId);
            
            if (currentIndex > 0) {
                // Swap with the previous H3
                const currentH3 = siblingH3s[currentIndex];
                const previousH3 = siblingH3s[currentIndex - 1];
                
                // Update orders
                currentH3.order = previousH3.order;
                previousH3.order = currentH3.order + 1;
                
                // Update backend
                updateBackendData().then(() => {
                    renderKeywords();
                    showNotification('H3 section moved up successfully', 'success');
                }).catch(error => {
                    console.error('Error updating backend data:', error);
                    showNotification('Error moving H3 section. Please try again.', 'error');
                });
            }
        }

        function moveH3Down(keywordId) {
            const h3Keyword = filteredData.find(kw => kw.id === keywordId);
            if (!h3Keyword || h3Keyword.tag !== 'H3' || !h3Keyword.parent_id) return;
            
            // Get all H3 keywords that belong to the same parent H2
            const siblingH3s = filteredData.filter(kw => 
                kw.tag === 'H3' && kw.parent_id === h3Keyword.parent_id
            ).sort((a, b) => a.order - b.order);
            
            const currentIndex = siblingH3s.findIndex(kw => kw.id === keywordId);
            
            if (currentIndex < siblingH3s.length - 1) {
                // Swap with the next H3
                const currentH3 = siblingH3s[currentIndex];
                const nextH3 = siblingH3s[currentIndex + 1];
                
                // Update orders
                currentH3.order = nextH3.order;
                nextH3.order = currentH3.order - 1;
                
                // Update backend
                updateBackendData().then(() => {
                    renderKeywords();
                    showNotification('H3 section moved down successfully', 'success');
                }).catch(error => {
                    console.error('Error updating backend data:', error);
                    showNotification('Error moving H3 section. Please try again.', 'error');
                });
            }
        }

        function handleDragStart(e) {
            e.target.classList.add('dragging');
            e.dataTransfer.setData('text/plain', e.target.dataset.id);
            
            // Add visual feedback for H3 keywords being dragged
            const keywordId = parseInt(e.target.dataset.id);
            const keyword = filteredData.find(kw => kw.id === keywordId);
            if (keyword && keyword.tag === 'H3') {
                e.target.classList.add('dragging');
                // Show drop zones for H2 keywords
                const h2Cards = document.querySelectorAll('.keyword-card.tag-h2');
                h2Cards.forEach(card => {
                    card.style.border = '2px dashed #333333';
                    card.style.backgroundColor = 'rgba(51, 51, 51, 0.1)';
                });
            }
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            
            // Reset any H2 cards that might have been highlighted
            const h2Cards = document.querySelectorAll('.keyword-card.tag-h2');
            h2Cards.forEach(card => {
                card.style.border = '';
                card.style.backgroundColor = '';
                card.classList.remove('drag-over');
            });
        }

        function handleDragOver(e) {
            e.preventDefault();
        }

        function handleDrop(e) {
            e.preventDefault();
            const draggedId = parseInt(e.dataTransfer.getData('text/plain'));
            const targetId = parseInt(e.target.closest('.keyword-card').dataset.id);
            
            if (draggedId !== targetId) {
                reorderKeywords(draggedId, targetId);
            }
        }
        
        function handleH2DragOver(e) {
            e.preventDefault();
            const draggedId = parseInt(e.dataTransfer.getData('text/plain'));
            const draggedKeyword = filteredData.find(kw => kw.id === draggedId);
            
            // Only allow H3 keywords to be dropped on H2 keywords
            if (draggedKeyword && draggedKeyword.tag === 'H3') {
                const h2Card = e.target.closest('.keyword-card');
                h2Card.classList.add('drag-over');
            }
        }
        
        function handleH2Drop(e) {
            e.preventDefault();
            const draggedId = parseInt(e.dataTransfer.getData('text/plain'));
            const targetId = parseInt(e.target.closest('.keyword-card').dataset.id);
            
            const draggedKeyword = filteredData.find(kw => kw.id === draggedId);
            const targetKeyword = filteredData.find(kw => kw.id === targetId);
            
            // Reset styling
            const h2Card = e.target.closest('.keyword-card');
            h2Card.classList.remove('drag-over');
            
            // Only allow H3 keywords to be dropped on H2 keywords
            if (draggedKeyword && draggedKeyword.tag === 'H3' && targetKeyword && targetKeyword.tag === 'H2') {
                // Assign the H3 keyword to the H2 keyword
                draggedKeyword.parent_id = targetKeyword.id;
                
                // Update backend
                updateBackendData().then(() => {
                    renderKeywords();
                    showNotification(`"${draggedKeyword.keyword}" assigned to "${targetKeyword.keyword}"`, 'success');
                }).catch(error => {
                    console.error('Error updating backend data:', error);
                    showNotification('Error assigning keyword. Please try again.', 'error');
                });
            }
        }

        function reorderKeywords(draggedId, targetId) {
            const draggedIndex = filteredData.findIndex(kw => kw.id === draggedId);
            const targetIndex = filteredData.findIndex(kw => kw.id === targetId);
            
            if (draggedIndex !== -1 && targetIndex !== -1) {
                const [draggedItem] = filteredData.splice(draggedIndex, 1);
                filteredData.splice(targetIndex, 0, draggedItem);
                
                // Update order in backend
                const newOrder = filteredData.map(kw => kw.id);
                
                fetch('/reorder', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ order: newOrder })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        renderKeywords();
                        showNotification('Keywords reordered successfully', 'success');
                    } else {
                        showNotification(data.error, 'error');
                    }
                })
                .catch(error => {
                    showNotification('Error reordering keywords: ' + error.message, 'error');
                });
            }
        }

        function showControls() {
            document.getElementById('controlsPanel').style.display = 'block';
            document.getElementById('keywordsContainer').style.display = 'block';
        }

        function testConnection() {
            console.log('Testing connection...'); // Debug log
            fetch('/test')
                .then(response => response.json())
                .then(data => {
                    console.log('Test response:', data); // Debug log
                    showNotification('Connection test successful!', 'success');
                })
                .catch(error => {
                    console.error('Test error:', error); // Debug log
                    showNotification('Connection test failed: ' + error.message, 'error');
                });
        }

        function handleCheckboxChange(checkbox) {
            // Add/remove selected class to keyword text
            const keywordCard = checkbox.closest('.keyword-card');
            const keywordText = keywordCard.querySelector('.keyword-text');
            if (checkbox.checked) {
                keywordText.classList.add('selected');
                console.log('Added selected class to:', keywordText.textContent);
                console.log('Element classes:', keywordText.className);
                console.log('Parent card classes:', keywordCard.className);
            } else {
                keywordText.classList.remove('selected');
                console.log('Removed selected class from:', keywordText.textContent);
            }
            
            updateRemoveButton();
        }
        
        function updateRemoveButton() {
            const checkedBoxes = document.querySelectorAll('.keyword-checkbox:checked');
            const removeBtn = document.getElementById('removeH2Btn');
            
            if (checkedBoxes.length > 0) {
                removeBtn.style.display = 'inline-block';
                removeBtn.innerHTML = `<i class="fas fa-trash"></i> Remove Selected (${checkedBoxes.length})`;
            } else {
                removeBtn.style.display = 'none';
            }
        }
        
        function removeSelectedH2s() {
            const checkedBoxes = document.querySelectorAll('.keyword-checkbox:checked');
            const selectedIds = Array.from(checkedBoxes).map(cb => parseInt(cb.value));
            
            if (selectedIds.length === 0) return;
            
            console.log('Removing keywords with IDs:', selectedIds);
            console.log('Before removal - filteredData length:', filteredData.length);
            
            // Get the keywords that will be removed for debugging
            const keywordsToRemove = filteredData.filter(kw => selectedIds.includes(kw.id));
            console.log('Keywords to remove:', keywordsToRemove.map(kw => ({ id: kw.id, keyword: kw.keyword, tag: kw.tag })));
            
            // Remove from filtered data (this is what we're working with)
            filteredData = filteredData.filter(kw => !selectedIds.includes(kw.id));
            
            console.log('After removal - filteredData length:', filteredData.length);
            console.log('Remaining keywords:', filteredData.map(kw => ({ id: kw.id, keyword: kw.keyword, tag: kw.tag })));
            
            // Update order
            for (let i = 0; i < filteredData.length; i++) {
                filteredData[i].order = i;
            }
            
            // Update backend with the new data and wait for completion
            updateBackendData().then(() => {
                renderKeywords();
                showNotification(`Removed ${selectedIds.length} keywords`, 'success');
            }).catch(error => {
                console.error('Error updating backend data:', error);
                showNotification('Error updating data. Please try again.', 'error');
            });
        }
        
        function updateBackendData() {
            // Send updated data to backend (use filteredData since that's what we're working with)
            return fetch('/update_data', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ data: filteredData })
            })
            .then(response => response.json())
            .then(data => {
                if (!data.success) {
                    console.error('Failed to update backend data');
                    throw new Error('Failed to update backend data');
                }
                return data;
            })
            .catch(error => {
                console.error('Error updating backend data:', error);
                throw error;
            });
        }
        
        function editKeyword(keywordId) {
            const keyword = filteredData.find(kw => kw.id === keywordId);
            if (!keyword) return;
            
            // Find the keyword text element
            const keywordElement = document.querySelector(`[data-id="${keywordId}"] .keyword-text`);
            if (!keywordElement) return;
            
            const originalText = keyword.keyword;
            
            // Create input field
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'edit-input';
            input.value = originalText;
            
            // Replace text with input
            keywordElement.innerHTML = '';
            keywordElement.appendChild(input);
            keywordElement.classList.add('editing');
            
            // Focus and select all text
            input.focus();
            input.select();
            
            // Save function
            const saveEdit = () => {
                let newValue = input.value.trim();
                if (newValue && newValue !== originalText) {
                    // Capitalize first letter of each word for H1 and H2
                    if (keyword.tag === 'H1' || keyword.tag === 'H2') {
                        newValue = newValue.toLowerCase().replace(/\b\w/g, l => l.toUpperCase());
                    }
                    
                    keyword.keyword = newValue;
                    renderKeywords();
                    showNotification('Keyword updated', 'success');
                } else {
                    // Restore original if empty or unchanged
                    keywordElement.innerHTML = originalText;
                    keywordElement.classList.remove('editing');
                }
            };
            
            // Cancel function
            const cancelEdit = () => {
                keywordElement.innerHTML = originalText;
                keywordElement.classList.remove('editing');
            };
            
            // Event listeners
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    saveEdit();
                } else if (e.key === 'Escape') {
                    cancelEdit();
                }
            });
            
            // Auto-save on blur (when input loses focus)
            input.addEventListener('blur', () => {
                saveEdit();
            });
            
            // Click outside to save (redundant with blur, but good for UX)
            const handleClickOutside = (e) => {
                if (!keywordElement.contains(e.target)) {
                    saveEdit();
                    document.removeEventListener('click', handleClickOutside);
                }
            };
            
            // Delay to prevent immediate trigger
            setTimeout(() => {
                document.addEventListener('click', handleClickOutside);
            }, 100);
        }
        
        function toggleSelectAll() {
            const selectAllCheckbox = document.getElementById('selectAllCheckbox');
            const allCheckboxes = document.querySelectorAll('.keyword-checkbox');
            
            allCheckboxes.forEach(checkbox => {
                checkbox.checked = selectAllCheckbox.checked;
                // Add/remove selected class to keyword text
                const keywordCard = checkbox.closest('.keyword-card');
                const keywordText = keywordCard.querySelector('.keyword-text');
                if (checkbox.checked) {
                    keywordText.classList.add('selected');
                } else {
                    keywordText.classList.remove('selected');
                }
            });
            
            updateRemoveButton();
        }
        
        function addNewH2() {
            const newKeyword = prompt('Enter new H2 keyword:');
            if (newKeyword && newKeyword.trim() !== '') {
                // Capitalize first letter of each word for H2
                let capitalizedKeyword = newKeyword.trim().toLowerCase().replace(/\b\w/g, l => l.toUpperCase());
                
                const newId = Math.max(...filteredData.map(kw => kw.id), 0) + 1;
                const newH2 = {
                    id: newId,
                    keyword: capitalizedKeyword,
                    volume: 0,
                    intent: '',
                    difficulty: 0,
                    cpc: 0,
                    tag: 'H2',
                    order: filteredData.length
                };
                
                filteredData.push(newH2);
                
                renderKeywords();
                showNotification('New H2 keyword added', 'success');
            }
        }
        


        function searchKeywords() {
            const searchTerm = document.getElementById('keywordSearch').value.toLowerCase().trim();
            const searchResults = document.getElementById('searchResults');
            const searchResultsList = document.getElementById('searchResultsList');
            const searchCount = document.getElementById('searchCount');
            
            if (searchTerm === '') {
                searchResults.style.display = 'none';
                return;
            }
            
            // Search in filteredData
            const results = filteredData.filter(keyword => 
                keyword.keyword.toLowerCase().includes(searchTerm)
            );
            
            // Display results
            searchResultsList.innerHTML = '';
            
            if (results.length === 0) {
                searchResultsList.innerHTML = '<div class="p-3 text-center text-muted">No keywords found matching your search.</div>';
            } else {
                results.forEach(keyword => {
                    const resultItem = createSearchResultItem(keyword);
                    searchResultsList.appendChild(resultItem);
                });
            }
            
            searchCount.textContent = results.length;
            searchResults.style.display = 'block';
        }
        
        function createSearchResultItem(keyword) {
            const item = document.createElement('div');
            item.className = 'search-result-item';
            
            const tagClass = keyword.tag ? keyword.tag.toLowerCase() : 'untagged';
            const tagText = keyword.tag || 'Untagged';
            
            item.innerHTML = `
                <div class="search-result-info">
                    <div class="search-result-keyword">${keyword.keyword}</div>
                    <div class="search-result-details">
                        Volume: ${keyword.volume.toLocaleString()} | 
                        Difficulty: ${keyword.difficulty} | 
                        CPC: $${keyword.cpc} | 
                        Intent: ${keyword.intent || 'N/A'}
                    </div>
                </div>
                <div class="search-result-actions">
                    <span class="search-result-tag ${tagClass}">${tagText}</span>
                    <button class="btn btn-sm btn-outline-danger" onclick="removeKeywordFromSearch(${keyword.id})" title="Remove keyword">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            `;
            
            return item;
        }
        
        function removeKeywordFromSearch(keywordId) {
            // Remove from filteredData
            filteredData = filteredData.filter(kw => kw.id !== keywordId);
            
            // Update order
            for (let i = 0; i < filteredData.length; i++) {
                filteredData[i].order = i;
            }
            
            // Update backend
            updateBackendData().then(() => {
                // Refresh search results
                searchKeywords();
                // Refresh main keyword list
                renderKeywords();
                showNotification('Keyword removed successfully', 'success');
            }).catch(error => {
                console.error('Error updating backend data:', error);
                showNotification('Error removing keyword. Please try again.', 'error');
            });
        }
        
        function clearSearch() {
            document.getElementById('keywordSearch').value = '';
            document.getElementById('searchResults').style.display = 'none';
        }
        
        function generateContent() {
            const generateBtn = document.getElementById('generateBtn');
            const originalText = generateBtn.innerHTML;
            
            // Show loading state
            generateBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Generating...';
            generateBtn.disabled = true;
            
            console.log('Generating content for filteredData length:', filteredData.length);
            
            // Get identifier data from form inputs
            const handle = document.getElementById('projectHandle').value.trim();
            const tags = document.getElementById('projectTags').value.trim();
            
            // Get hero section data from form inputs
            const heroTagline = document.getElementById('heroTagline').value.trim();
            const heroCTA = document.getElementById('heroCTA').value.trim();
            const heroCTALink = document.getElementById('heroCTALink').value.trim();
            
            // Validate hero section data
            if (!heroTagline || !heroCTA || !heroCTALink) {
                showNotification('Please fill in all hero section fields (Tagline, CTA Text, and CTA Link)', 'error');
                generateBtn.innerHTML = originalText;
                generateBtn.disabled = false;
                return;
            }
            
            // Store identifier data for later use in the final output
            const identifierData = {
                handle: handle || 'default-handle',
                tags: tags || 'default-tags'
            };
            
            // Store hero section data
            const heroData = {
                tagline: heroTagline,
                cta_text: heroCTA,
                cta_link: heroCTALink
            };
            
            // First, ensure backend is synced with the data we want to generate content for
            updateBackendData().then(() => {
                // Then generate content with a small delay to ensure backend has processed the update
                setTimeout(() => {
                    fetch('/generate_content', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ 
                            data: filteredData,
                            identifier: identifierData,
                            hero: heroData
                        })
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            // Show success message with file location
                            const successMessage = `✅ Content generated successfully! 
File saved to: D:/articles/nails/${data.filename}`;
                            showNotification(successMessage, 'success');
                            
                            // Show summary in console
                            console.log('Generated Content Summary:', data.summary);
                            console.log('File saved to:', data.file_path);
                            
                            // Show summary in a more detailed notification
                            const summary = data.summary;
                            const summaryText = `
📄 Content Summary:
• Title: ${summary.title}
• Meta Description: ${summary.meta_description}
• Hero Tagline: ${summary.hero_tagline}
• Hero CTA: ${summary.hero_cta}
• Hero CTA Link: ${summary.hero_cta_link}
• H2 Sections: ${summary.h2_sections}
• FAQs Generated: ${summary.faqs_generated}
• File Location: D:/articles/nails/${data.filename}
                            `;
                            showNotification(summaryText, 'success');
                            
                            // Automatically download the generated JSON file
                            downloadGeneratedContent(data.filename);
                        } else {
                            showNotification('Error generating content: ' + data.error, 'error');
                        }
                    })
                    .catch(error => {
                        showNotification('Error generating content: ' + error.message, 'error');
                    })
                    .finally(() => {
                        // Reset button state
                        generateBtn.innerHTML = originalText;
                        generateBtn.disabled = false;
                    });
                }, 200); // 200ms delay after backend sync
            }).catch(error => {
                console.error('Error syncing with backend before content generation:', error);
                showNotification('Error syncing data before content generation. Please try again.', 'error');
                // Reset button state
                generateBtn.innerHTML = originalText;
                generateBtn.disabled = false;
            });
        }
        
        function downloadGeneratedContent(filename) {
            // Create a download link for the generated file
            const link = document.createElement('a');
            link.href = `/download_generated/${filename}`;
            link.download = filename;
            link.style.display = 'none';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            showNotification(`📥 File downloaded: ${filename}`, 'success');
        }
        

        
        function copyKeyword(keyword) {
            // Copy the keyword to clipboard
            navigator.clipboard.writeText(keyword).then(() => {
                // Find the copy icon and add visual feedback
                const copyIcons = document.querySelectorAll('.copy-icon');
                copyIcons.forEach(icon => {
                    if (icon.parentElement.textContent.includes(keyword)) {
                        icon.classList.add('copied');
                        // Remove the copied class after animation
                        setTimeout(() => {
                            icon.classList.remove('copied');
                        }, 500);
                    }
                });
                
                // Show success notification
                showNotification(`✅ Copied: "${keyword}"`, 'success');
            }).catch(err => {
                console.error('Failed to copy keyword:', err);
                showNotification('❌ Failed to copy keyword', 'error');
            });
        }

        function showNotification(message, type) {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = `alert alert-${type === 'error' ? 'danger' : 'success'} alert-dismissible fade show position-fixed`;
            notification.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 300px;';
            notification.innerHTML = `
                ${message}
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            `;
            
            document.body.appendChild(notification);
            
            // Auto remove after 5 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.remove();
                }
            }, 5000);
        }
    </script>
</body>
</html>
